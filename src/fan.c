#include "fan.h"
#include "sam.h"
#include "same51j20a.h"

// hardware setup: 5V power; PA11 is our output (pwm); PB07is our input (ext input). I/O can change to another pin as long as it has same functions.

// There is no output adjusting done. You'll need to add that and anything else you need for messaging, matching RPM (a PID?), and...

// setup our heartbeat to be 1ms: so we overflow at 1ms intervals with a 48MHz clock
#define MS_TICKS 48000UL

// conversion factor for our RPM calculations, with a clock running at a fraction of our heartbeat
// running at 12MHz to ensure that we have enough time to capture slowest RPM
#define RPM_CLOCK_DIV 4
#define RPM_MS_FACTOR (MS_TICKS/RPM_CLOCK_DIV)

// see fan data sheet for pulses to capture for accurate RPM calculations
#define START_PULSE 1
#define END_PULSE 3


// values updated inside an interrupt and needed outside 
volatile uint16_t fanRPM = 0;


void updateOutput(uint8_t dutyCycle)
{
  TC1_REGS->COUNT8.TC_CC[1] = dutyCycle;
}

void fanInit()
{
  // setup the output control pin
  PORT_REGS->GROUP[0].PORT_DIRSET = PORT_PA11;
  PORT_REGS->GROUP[0].PORT_OUTSET = PORT_PA11;
  PORT_REGS->GROUP[0].PORT_PINCFG[11] |= PORT_PINCFG_PMUXEN_Msk;
  PORT_REGS->GROUP[0].PORT_PMUX[5] |= PORT_PMUX_PMUXO_E;
 
  // use generic clock 4 as our clock for this device, slowing the clock to make the duty cycle changes noticeable
  // this is set in conjunction with the pre-scaler (below) to give a frequency in kHz
  GCLK_REGS->GCLK_GENCTRL[4] = GCLK_GENCTRL_DIV(4) | GCLK_GENCTRL_SRC_DFLL | GCLK_GENCTRL_GENEN_Msk;
  while((GCLK_REGS->GCLK_SYNCBUSY & GCLK_SYNCBUSY_GENCTRL_GCLK0) == GCLK_SYNCBUSY_GENCTRL_GCLK0)
    ;/* Wait for synchronization */

  // have to enable the peripheral clocks I need via the generic and main clocks
  // see page 156 of data sheet for GCLK array offsets
  GCLK_REGS->GCLK_PCHCTRL[9] = GCLK_PCHCTRL_GEN(4) | GCLK_PCHCTRL_CHEN_Msk;
  while ((GCLK_REGS->GCLK_PCHCTRL[9] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
    ;/* Wait for synchronization */

  MCLK_REGS->MCLK_APBAMASK |= MCLK_APBAMASK_TC1_Msk;

  // this is the pre-scaler I chose so I can demonstrate "stiction"
  TC1_REGS->COUNT8.TC_CTRLA = TC_CTRLA_MODE_COUNT8 | TC_CTRLA_PRESCALER_DIV256;

  TC1_REGS->COUNT8.TC_WAVE = TC_WAVE_WAVEGEN_NPWM;

  // start the timer
  TC1_REGS->COUNT8.TC_CTRLA |= TC_CTRLA_ENABLE_Msk;
}

void rpmInit()
{
  // RPM input, with a pull-up (using internal but we should use an external 1K for a less glitchy signal)
  PORT_REGS->GROUP[1].PORT_DIRCLR = PORT_PB07;
  PORT_REGS->GROUP[1].PORT_PINCFG[7] = PORT_PINCFG_PMUXEN_Msk | PORT_PINCFG_PULLEN_Msk;
  PORT_REGS->GROUP[1].PORT_OUTSET = PORT_PB07;

  //setup the event system
  MCLK_REGS->MCLK_APBBMASK |= MCLK_APBBMASK_EVSYS_Msk;
  // see data sheet page 798 for indices (TCC0 MC0 used here) and page 799 for channel selection (channel 0, generated by ext int 14 as set below)
  EVSYS_REGS->EVSYS_USER[19] = 0x01;
  // see data sheet page 792 for event generator values (Ext Int 14 used here)
  EVSYS_REGS->CHANNEL[0].EVSYS_CHANNEL = EVSYS_CHANNEL_EVGEN(0x20) | EVSYS_CHANNEL_PATH_ASYNCHRONOUS;

  // RPM input goes to an external interrupt, with events being generated for each rising edge
  PORT_REGS->GROUP[0].PORT_PMUX[7] = PORT_PMUX_PMUXE_A;
  EIC_REGS->EIC_CONFIG[1] = EIC_CONFIG_SENSE6_RISE;
  //Use This? EIC_EXTINT_14_IRQn
  EIC_REGS->EIC_EVCTRL = EXTINT14_MASK;
  EIC_REGS->EIC_CTRLA = EIC_CTRLA_CKSEL_CLK_ULP32K | EIC_CTRLA_ENABLE_Msk;

  // input events are then captured using TCC0

  // use generic clock 5 as our clock for this device
  GCLK_REGS->GCLK_GENCTRL[5] = GCLK_GENCTRL_DIV(RPM_CLOCK_DIV) | GCLK_GENCTRL_SRC_DFLL | GCLK_GENCTRL_GENEN_Msk;
  while((GCLK_REGS->GCLK_SYNCBUSY & GCLK_SYNCBUSY_GENCTRL_GCLK0) == GCLK_SYNCBUSY_GENCTRL_GCLK0)
    ;/* Wait for synchronization */

  // have to enable the peripheral clocks I need via the generic and main clocks
  // see page 156 of data sheet for GCLK array offsets
  GCLK_REGS->GCLK_PCHCTRL[25] = GCLK_PCHCTRL_GEN(5) | GCLK_PCHCTRL_CHEN_Msk;
  while ((GCLK_REGS->GCLK_PCHCTRL[25] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
    ;/* Wait for synchronization */

  MCLK_REGS->MCLK_APBBMASK |= MCLK_APBBMASK_TCC0_Msk;

  TCC0_REGS->TCC_EVCTRL = TCC_EVCTRL_MCEI0_Msk;
  TCC0_REGS->TCC_INTENSET = TCC_INTENSET_MC0_Msk | TCC_INTENSET_OVF_Msk;
  TCC0_REGS->TCC_CTRLA = TCC_CTRLA_CPTEN0_Msk | TCC_CTRLA_ENABLE_Msk;

  NVIC_EnableIRQ(TCC0_MC0_IRQn);
  NVIC_EnableIRQ(TCC0_OTHER_IRQn);
}

// clock is setup to ensure that it never overflows within our RPM range; an overflow indicates no pulse, or that the fan has stopped
void TCC0_OTHER_Handler()
{
  if ((TCC0_REGS->TCC_INTFLAG & TCC_INTFLAG_OVF_Msk) == TCC_INTFLAG_OVF_Msk)
  {
    fanRPM = 0;
    // clear the interrupt!
    TCC0_REGS->TCC_INTFLAG |= TCC_INTFLAG_OVF_Msk;
  }
}

// we do need averaging as there is some jitter in the feedback from the fan
#define NUM_SAMPLES 16
// ISR for match capture events
void TCC0_MC0_Handler()
{
  static uint8_t  pulseCount = 0;
  static uint32_t samples[NUM_SAMPLES] = {0};
  static uint16_t sampleIndex = 0;
  static uint16_t sampleCount = 0;
  static uint32_t sampleAvg = 0;
  uint32_t nextSample = 0;

  // reading the capture register resets the interrupt, rounded to the nearest millisecond (we don't need greater accuracy!)
  nextSample = (TCC0_REGS->TCC_CC[0] + (RPM_MS_FACTOR/2))/RPM_MS_FACTOR;
 
  pulseCount++;
  // on first pulse, start our count
  if (pulseCount == START_PULSE)
  {
    TCC0_REGS->TCC_COUNT = 0;
  }
  // on every third count we have another sample to record
  if (pulseCount == END_PULSE)
  {
    // replace oldest value with newest for the running averaging
    sampleAvg -= samples[sampleIndex];
    // fan data sheet indicates this is the conversion to perform after every 3 positive edges
    samples[sampleIndex] = 60000/nextSample;
    sampleAvg += samples[sampleIndex];
    sampleIndex = (sampleIndex+1)%NUM_SAMPLES;
  
    // stop counting after we have full history
    if (sampleCount < NUM_SAMPLES)
      sampleCount++;

    fanRPM = sampleAvg/sampleCount;

    // now we can use the last edge as the first for our next sample!
    pulseCount = START_PULSE;
    TCC0_REGS->TCC_COUNT = 0;
  }
}
