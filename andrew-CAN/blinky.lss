
blinky.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000a90  00000000  00000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000004  20000000  00000a90  00002000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  00002004  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  00002004  2**0
                  CONTENTS
  4 .bss          000001b8  20000004  00000a94  00002004  2**2
                  ALLOC
  5 .stack        00010004  200001bc  00000c4c  00002004  2**0
                  ALLOC
  6 .ARM.attributes 0000002a  00000000  00000000  00002004  2**0
                  CONTENTS, READONLY
  7 .comment      00000045  00000000  00000000  0000202e  2**0
                  CONTENTS, READONLY
  8 .debug_info   00003607  00000000  00000000  00002073  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_abbrev 00000836  00000000  00000000  0000567a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_loclists 000004e9  00000000  00000000  00005eb0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_aranges 00000170  00000000  00000000  00006399  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_rnglists 0000010a  00000000  00000000  00006509  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_line   0000110d  00000000  00000000  00006613  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_str    0000146d  00000000  00000000  00007720  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_frame  000004c4  00000000  00000000  00008b90  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00000000 <exception_table>:
		len -= 2;
	}
}

void dbg_write_u8(const unsigned char *val, long len)
{
   0:	c0 01 01 20 f1 02 00 00 ed 02 00 00 ed 02 00 00     ... ............
	unsigned long dcc_data;

	dbg_write(TARGET_REQ_DEBUGMSG_HEXMSG(1) | ((len & 0xffff) << 16));
  10:	ed 02 00 00 ed 02 00 00 ed 02 00 00 00 00 00 00     ................
	...

	while (len > 0)
	{
		dcc_data = val[0] | ((len > 1) ? val[1] << 8 : 0x00) | ((len > 2) ? val[2] << 16 : 0x00) | ((len > 3) ? val[3] << 24 : 0x00);
  2c:	ed 02 00 00 ed 02 00 00 00 00 00 00 ed 02 00 00     ................
  3c:	59 08 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     Y...............

		dbg_write(dcc_data);
  4c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  dbg_write_str(caller);
  dbg_write_char('(');
  // this could be more robust; just printing the hex value is easier but less useful
  dbg_write_char(lineNum / 1000 + '0');
  dbg_write_char((lineNum / 100) % 10 + '0');
  dbg_write_char((lineNum / 10) % 10 + '0');
  5c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  6c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  dbg_write_char(lineNum % 10 + '0');
  dbg_write_char(')');
  7c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................

  // for debugging purposes *this* is all the code we really need
  // don't breakpoint if we're not running via a debugger, otherwise we stop 'forever'
  if ((CoreDebug->DHCSR & CoreDebug_DHCSR_C_DEBUGEN_Msk) == CoreDebug_DHCSR_C_DEBUGEN_Msk)
    __BKPT(0);
  8c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  9c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  ac:	69 08 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     i...............
  bc:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  cc:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  dc:	ed 02 00 00 ed 02 00 00 ed 02 00 00 00 00 00 00     ................
	...
  f4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 104:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 114:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 124:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 134:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 144:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 154:	ed 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
 178:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 188:	ed 02 00 00 ed 02 00 00 00 00 00 00 ed 02 00 00     ................
 198:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 1a8:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 1b8:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 1c8:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 1d8:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 1e8:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 1f8:	ed 02 00 00 ed 02 00 00 ed 02 00 00 00 00 00 00     ................
 208:	00 00 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 218:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 228:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 238:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 248:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 258:	ed 02 00 00 ed 02 00 00                             ........

00000260 <deregister_tm_clones>:
 260:	4803      	ldr	r0, [pc, #12]	@ (270 <deregister_tm_clones+0x10>)
 262:	4b04      	ldr	r3, [pc, #16]	@ (274 <deregister_tm_clones+0x14>)
 264:	4283      	cmp	r3, r0
 266:	d002      	beq.n	26e <deregister_tm_clones+0xe>
 268:	4b03      	ldr	r3, [pc, #12]	@ (278 <deregister_tm_clones+0x18>)
 26a:	b103      	cbz	r3, 26e <deregister_tm_clones+0xe>
 26c:	4718      	bx	r3
 26e:	4770      	bx	lr
 270:	00000a90 	.word	0x00000a90
 274:	00000a90 	.word	0x00000a90
 278:	00000000 	.word	0x00000000

0000027c <register_tm_clones>:
 27c:	4805      	ldr	r0, [pc, #20]	@ (294 <register_tm_clones+0x18>)
 27e:	4b06      	ldr	r3, [pc, #24]	@ (298 <register_tm_clones+0x1c>)
 280:	1a1b      	subs	r3, r3, r0
 282:	0fd9      	lsrs	r1, r3, #31
 284:	eb01 01a3 	add.w	r1, r1, r3, asr #2
 288:	1049      	asrs	r1, r1, #1
 28a:	d002      	beq.n	292 <register_tm_clones+0x16>
 28c:	4b03      	ldr	r3, [pc, #12]	@ (29c <register_tm_clones+0x20>)
 28e:	b103      	cbz	r3, 292 <register_tm_clones+0x16>
 290:	4718      	bx	r3
 292:	4770      	bx	lr
 294:	00000a90 	.word	0x00000a90
 298:	00000a90 	.word	0x00000a90
 29c:	00000000 	.word	0x00000000

000002a0 <__do_global_dtors_aux>:
 2a0:	b510      	push	{r4, lr}
 2a2:	4c06      	ldr	r4, [pc, #24]	@ (2bc <__do_global_dtors_aux+0x1c>)
 2a4:	7823      	ldrb	r3, [r4, #0]
 2a6:	b943      	cbnz	r3, 2ba <__do_global_dtors_aux+0x1a>
 2a8:	f7ff ffda 	bl	260 <deregister_tm_clones>
 2ac:	4b04      	ldr	r3, [pc, #16]	@ (2c0 <__do_global_dtors_aux+0x20>)
 2ae:	b113      	cbz	r3, 2b6 <__do_global_dtors_aux+0x16>
 2b0:	4804      	ldr	r0, [pc, #16]	@ (2c4 <__do_global_dtors_aux+0x24>)
 2b2:	f3af 8000 	nop.w
 2b6:	2301      	movs	r3, #1
 2b8:	7023      	strb	r3, [r4, #0]
 2ba:	bd10      	pop	{r4, pc}
 2bc:	20000004 	.word	0x20000004
 2c0:	00000000 	.word	0x00000000
 2c4:	00000a90 	.word	0x00000a90

000002c8 <frame_dummy>:
 2c8:	b508      	push	{r3, lr}
 2ca:	4b05      	ldr	r3, [pc, #20]	@ (2e0 <frame_dummy+0x18>)
 2cc:	b11b      	cbz	r3, 2d6 <frame_dummy+0xe>
 2ce:	4905      	ldr	r1, [pc, #20]	@ (2e4 <frame_dummy+0x1c>)
 2d0:	4805      	ldr	r0, [pc, #20]	@ (2e8 <frame_dummy+0x20>)
 2d2:	f3af 8000 	nop.w
 2d6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 2da:	f7ff bfcf 	b.w	27c <register_tm_clones>
 2de:	bf00      	nop
 2e0:	00000000 	.word	0x00000000
 2e4:	20000008 	.word	0x20000008
 2e8:	00000a90 	.word	0x00000a90

000002ec <Dummy_Handler>:
 2ec:	e7fe      	b.n	2ec <Dummy_Handler>
	...

000002f0 <Reset_Handler>:
 2f0:	b508      	push	{r3, lr}
 2f2:	4a1a      	ldr	r2, [pc, #104]	@ (35c <Reset_Handler+0x6c>)
 2f4:	4b1a      	ldr	r3, [pc, #104]	@ (360 <Reset_Handler+0x70>)
 2f6:	429a      	cmp	r2, r3
 2f8:	d010      	beq.n	31c <Reset_Handler+0x2c>
 2fa:	461a      	mov	r2, r3
 2fc:	4b19      	ldr	r3, [pc, #100]	@ (364 <Reset_Handler+0x74>)
 2fe:	429a      	cmp	r2, r3
 300:	d20c      	bcs.n	31c <Reset_Handler+0x2c>
 302:	1e58      	subs	r0, r3, #1
 304:	1a80      	subs	r0, r0, r2
 306:	f020 0003 	bic.w	r0, r0, #3
 30a:	3004      	adds	r0, #4
 30c:	4b13      	ldr	r3, [pc, #76]	@ (35c <Reset_Handler+0x6c>)
 30e:	4418      	add	r0, r3
 310:	f853 1b04 	ldr.w	r1, [r3], #4
 314:	f842 1b04 	str.w	r1, [r2], #4
 318:	4283      	cmp	r3, r0
 31a:	d1f9      	bne.n	310 <Reset_Handler+0x20>
 31c:	4a12      	ldr	r2, [pc, #72]	@ (368 <Reset_Handler+0x78>)
 31e:	4b13      	ldr	r3, [pc, #76]	@ (36c <Reset_Handler+0x7c>)
 320:	429a      	cmp	r2, r3
 322:	d20b      	bcs.n	33c <Reset_Handler+0x4c>
 324:	4613      	mov	r3, r2
 326:	4a12      	ldr	r2, [pc, #72]	@ (370 <Reset_Handler+0x80>)
 328:	1ad2      	subs	r2, r2, r3
 32a:	f022 0203 	bic.w	r2, r2, #3
 32e:	3204      	adds	r2, #4
 330:	441a      	add	r2, r3
 332:	2100      	movs	r1, #0
 334:	f843 1b04 	str.w	r1, [r3], #4
 338:	429a      	cmp	r2, r3
 33a:	d1fb      	bne.n	334 <Reset_Handler+0x44>
 33c:	4b0d      	ldr	r3, [pc, #52]	@ (374 <Reset_Handler+0x84>)
 33e:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 342:	4a0d      	ldr	r2, [pc, #52]	@ (378 <Reset_Handler+0x88>)
 344:	6093      	str	r3, [r2, #8]
 346:	4b0d      	ldr	r3, [pc, #52]	@ (37c <Reset_Handler+0x8c>)
 348:	b103      	cbz	r3, 34c <Reset_Handler+0x5c>
 34a:	4798      	blx	r3
 34c:	f000 fae6 	bl	91c <__libc_init_array>
 350:	4b0b      	ldr	r3, [pc, #44]	@ (380 <Reset_Handler+0x90>)
 352:	b103      	cbz	r3, 356 <Reset_Handler+0x66>
 354:	4798      	blx	r3
 356:	f000 fa95 	bl	884 <main>
 35a:	e7fe      	b.n	35a <Reset_Handler+0x6a>
 35c:	00000a90 	.word	0x00000a90
 360:	20000000 	.word	0x20000000
 364:	20000004 	.word	0x20000004
 368:	20000004 	.word	0x20000004
 36c:	200001bc 	.word	0x200001bc
 370:	200001bb 	.word	0x200001bb
 374:	00000000 	.word	0x00000000
 378:	e000ed00 	.word	0xe000ed00
	...

00000384 <dbg_write>:
	if ((CoreDebug->DHCSR & CoreDebug_DHCSR_C_DEBUGEN_Msk) == CoreDebug_DHCSR_C_DEBUGEN_Msk)
 384:	4b0b      	ldr	r3, [pc, #44]	@ (3b4 <dbg_write+0x30>)
 386:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 38a:	f013 0f01 	tst.w	r3, #1
 38e:	d00f      	beq.n	3b0 <dbg_write+0x2c>
 390:	2104      	movs	r1, #4
			while (NVIC_DBG_DATA_R & BUSY)
 392:	4a08      	ldr	r2, [pc, #32]	@ (3b4 <dbg_write+0x30>)
 394:	f8b2 30f8 	ldrh.w	r3, [r2, #248]	@ 0xf8
 398:	f013 0f01 	tst.w	r3, #1
 39c:	d1fa      	bne.n	394 <dbg_write+0x10>
			NVIC_DBG_DATA_R = (unsigned short)(((dcc_data & 0xff) << 8) | BUSY);
 39e:	0203      	lsls	r3, r0, #8
 3a0:	f043 0301 	orr.w	r3, r3, #1
 3a4:	b29b      	uxth	r3, r3
 3a6:	f8a2 30f8 	strh.w	r3, [r2, #248]	@ 0xf8
			dcc_data >>= 8;
 3aa:	0a00      	lsrs	r0, r0, #8
		while (len--)
 3ac:	3901      	subs	r1, #1
 3ae:	d1f1      	bne.n	394 <dbg_write+0x10>
}
 3b0:	4770      	bx	lr
 3b2:	bf00      	nop
 3b4:	e000ed00 	.word	0xe000ed00

000003b8 <dbg_write_u32>:
{
 3b8:	b538      	push	{r3, r4, r5, lr}
 3ba:	4605      	mov	r5, r0
 3bc:	460c      	mov	r4, r1
	dbg_write(TARGET_REQ_DEBUGMSG_HEXMSG(4) | ((len & 0xffff) << 16));
 3be:	f240 4001 	movw	r0, #1025	@ 0x401
 3c2:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 3c6:	f7ff ffdd 	bl	384 <dbg_write>
	while (len > 0)
 3ca:	2c00      	cmp	r4, #0
 3cc:	dd05      	ble.n	3da <dbg_write_u32+0x22>
		dbg_write(*val);
 3ce:	f855 0b04 	ldr.w	r0, [r5], #4
 3d2:	f7ff ffd7 	bl	384 <dbg_write>
	while (len > 0)
 3d6:	3c01      	subs	r4, #1
 3d8:	d1f9      	bne.n	3ce <dbg_write_u32+0x16>
}
 3da:	bd38      	pop	{r3, r4, r5, pc}

000003dc <dbg_write_str>:
		len -= 4;
	}
}

void dbg_write_str(const char *msg)
{
 3dc:	b570      	push	{r4, r5, r6, lr}
	long len;
	unsigned long dcc_data;

	for (len = 0; msg[len] && (len < 65536); len++)
 3de:	7803      	ldrb	r3, [r0, #0]
 3e0:	b3ab      	cbz	r3, 44e <dbg_write_str+0x72>
 3e2:	4605      	mov	r5, r0
 3e4:	4603      	mov	r3, r0
 3e6:	2400      	movs	r4, #0
 3e8:	3401      	adds	r4, #1
 3ea:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 3ee:	b132      	cbz	r2, 3fe <dbg_write_str+0x22>
 3f0:	f5b4 3f80 	cmp.w	r4, #65536	@ 0x10000
 3f4:	d1f8      	bne.n	3e8 <dbg_write_str+0xc>
		;

	dbg_write(TARGET_REQ_DEBUGMSG_ASCII | ((len & 0xffff) << 16));
 3f6:	2001      	movs	r0, #1
 3f8:	f7ff ffc4 	bl	384 <dbg_write>

	while (len > 0)
 3fc:	e006      	b.n	40c <dbg_write_str+0x30>
	dbg_write(TARGET_REQ_DEBUGMSG_ASCII | ((len & 0xffff) << 16));
 3fe:	0420      	lsls	r0, r4, #16
 400:	f040 0001 	orr.w	r0, r0, #1
 404:	f7ff ffbe 	bl	384 <dbg_write>
	while (len > 0)
 408:	2c00      	cmp	r4, #0
 40a:	dd1f      	ble.n	44c <dbg_write_str+0x70>
 40c:	3504      	adds	r5, #4
	{
		dcc_data = msg[0] | ((len > 1) ? msg[1] << 8 : 0x00) | ((len > 2) ? msg[2] << 16 : 0x00) | ((len > 3) ? msg[3] << 24 : 0x00);
 40e:	2600      	movs	r6, #0
 410:	4628      	mov	r0, r5
 412:	f815 3c04 	ldrb.w	r3, [r5, #-4]
 416:	2c01      	cmp	r4, #1
 418:	bfc6      	itte	gt
 41a:	f815 2c03 	ldrbgt.w	r2, [r5, #-3]
 41e:	0212      	lslgt	r2, r2, #8
 420:	4632      	movle	r2, r6
 422:	4313      	orrs	r3, r2
 424:	2c02      	cmp	r4, #2
 426:	bfc6      	itte	gt
 428:	f815 2c02 	ldrbgt.w	r2, [r5, #-2]
 42c:	0412      	lslgt	r2, r2, #16
 42e:	4632      	movle	r2, r6
 430:	4313      	orrs	r3, r2
 432:	2c03      	cmp	r4, #3
 434:	bfc6      	itte	gt
 436:	f815 0c01 	ldrbgt.w	r0, [r5, #-1]
 43a:	0600      	lslgt	r0, r0, #24
 43c:	4630      	movle	r0, r6
		dbg_write(dcc_data);
 43e:	4318      	orrs	r0, r3
 440:	f7ff ffa0 	bl	384 <dbg_write>
	while (len > 0)
 444:	3504      	adds	r5, #4
 446:	3c04      	subs	r4, #4
 448:	2c00      	cmp	r4, #0
 44a:	dce1      	bgt.n	410 <dbg_write_str+0x34>

		msg += 4;
		len -= 4;
	}
}
 44c:	bd70      	pop	{r4, r5, r6, pc}
	dbg_write(TARGET_REQ_DEBUGMSG_ASCII | ((len & 0xffff) << 16));
 44e:	2001      	movs	r0, #1
 450:	f7ff ff98 	bl	384 <dbg_write>
	while (len > 0)
 454:	e7fa      	b.n	44c <dbg_write_str+0x70>
	...

00000458 <clkButton>:
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 458:	4b04      	ldr	r3, [pc, #16]	@ (46c <clkButton+0x14>)
 45a:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
 45e:	601a      	str	r2, [r3, #0]
void clkButton(){

	//enable intterrupt
    NVIC_EnableIRQ(EIC_EXTINT_15_IRQn);

    MCLK_REGS->MCLK_APBAMASK |= MCLK_APBAMASK_EIC_Msk;
 460:	4a03      	ldr	r2, [pc, #12]	@ (470 <clkButton+0x18>)
 462:	6953      	ldr	r3, [r2, #20]
 464:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 468:	6153      	str	r3, [r2, #20]

}//clkButton
 46a:	4770      	bx	lr
 46c:	e000e100 	.word	0xe000e100
 470:	40000800 	.word	0x40000800

00000474 <initButton>:

void initButton(){


   	EIC_REGS->EIC_CONFIG[1] |= ((uint32_t)(EXTINT15_MASK)<<16) | EIC_CONFIG_SENSE7_RISE;
 474:	4b0b      	ldr	r3, [pc, #44]	@ (4a4 <initButton+0x30>)
 476:	6a1a      	ldr	r2, [r3, #32]
 478:	f042 4210 	orr.w	r2, r2, #2415919104	@ 0x90000000
 47c:	621a      	str	r2, [r3, #32]
	EIC_REGS->EIC_DEBOUNCEN |= EXTINT15_MASK;
 47e:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 480:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 484:	631a      	str	r2, [r3, #48]	@ 0x30
	EIC_REGS->EIC_DPRESCALER |= EIC_DPRESCALER_TICKON_Msk | EIC_DPRESCALER_STATES1_Msk |  EIC_DPRESCALER_PRESCALER1_DIV64;
 486:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 488:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 48c:	f042 02d0 	orr.w	r2, r2, #208	@ 0xd0
 490:	635a      	str	r2, [r3, #52]	@ 0x34
	EIC_REGS->EIC_INTENSET |= EXTINT15_MASK;
 492:	691a      	ldr	r2, [r3, #16]
 494:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 498:	611a      	str	r2, [r3, #16]
	EIC_REGS->EIC_CTRLA |= EIC_CTRLA_CKSEL_CLK_ULP32K | EIC_CTRLA_ENABLE_Msk; 
 49a:	781a      	ldrb	r2, [r3, #0]
 49c:	f042 0212 	orr.w	r2, r2, #18
 4a0:	701a      	strb	r2, [r3, #0]

}//initButton
 4a2:	4770      	bx	lr
 4a4:	40002800 	.word	0x40002800

000004a8 <port15Init>:

void port15Init(){

 	// switch input on PA15, processed as an external interrupt
  	PORT_REGS->GROUP[0].PORT_DIRCLR = PORT_PA15;
 4a8:	4b0b      	ldr	r3, [pc, #44]	@ (4d8 <port15Init+0x30>)
 4aa:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 4ae:	6059      	str	r1, [r3, #4]
  	PORT_REGS->GROUP[0].PORT_PINCFG[15] |= PORT_PINCFG_PMUXEN_Msk;
 4b0:	f893 204f 	ldrb.w	r2, [r3, #79]	@ 0x4f
 4b4:	f042 0201 	orr.w	r2, r2, #1
 4b8:	f883 204f 	strb.w	r2, [r3, #79]	@ 0x4f
  	PORT_REGS->GROUP[0].PORT_PMUX[7] |= PORT_PMUX_PMUXO_A;
 4bc:	f893 2037 	ldrb.w	r2, [r3, #55]	@ 0x37
 4c0:	b2d2      	uxtb	r2, r2
 4c2:	f883 2037 	strb.w	r2, [r3, #55]	@ 0x37
	PORT_REGS->GROUP[0].PORT_OUTSET = PORT_PA15;
 4c6:	6199      	str	r1, [r3, #24]
	PORT_REGS->GROUP[0].PORT_PINCFG[15] |= PORT_PINCFG_PULLEN_Msk;
 4c8:	f893 204f 	ldrb.w	r2, [r3, #79]	@ 0x4f
 4cc:	f042 0204 	orr.w	r2, r2, #4
 4d0:	f883 204f 	strb.w	r2, [r3, #79]	@ 0x4f

 4d4:	4770      	bx	lr
 4d6:	bf00      	nop
 4d8:	41008000 	.word	0x41008000

000004dc <clkCAN>:
#include "can.h"
// We will use PA22 AND PA23 as are CAN TX and CAN RX respectively
void clkCAN(){

    GCLK_REGS->GCLK_PCHCTRL[CAN0_GCLK_ID] |= GCLK_PCHCTRL_CHEN_Msk;
 4dc:	4a08      	ldr	r2, [pc, #32]	@ (500 <clkCAN+0x24>)
 4de:	f8d2 30ec 	ldr.w	r3, [r2, #236]	@ 0xec
 4e2:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 4e6:	f8c2 30ec 	str.w	r3, [r2, #236]	@ 0xec
	while((GCLK_REGS->GCLK_PCHCTRL[CAN0_GCLK_ID] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk){
 4ea:	f8d2 30ec 	ldr.w	r3, [r2, #236]	@ 0xec
 4ee:	f013 0f40 	tst.w	r3, #64	@ 0x40
 4f2:	d0fa      	beq.n	4ea <clkCAN+0xe>
		//wait for sync
	}//while
	
    MCLK_REGS->MCLK_AHBMASK |= MCLK_AHBMASK_CAN0_Msk;
 4f4:	4a03      	ldr	r2, [pc, #12]	@ (504 <clkCAN+0x28>)
 4f6:	6913      	ldr	r3, [r2, #16]
 4f8:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 4fc:	6113      	str	r3, [r2, #16]

}//clkCAN
 4fe:	4770      	bx	lr
 500:	40001c00 	.word	0x40001c00
 504:	40000800 	.word	0x40000800

00000508 <initCAN>:

void initCAN(){

//set the init bit as per 39.6.2.1 to start init
CAN0_REGS->CAN_CCCR = CAN_CCCR_INIT_Msk;
 508:	f04f 4384 	mov.w	r3, #1107296256	@ 0x42000000
 50c:	2201      	movs	r2, #1
 50e:	619a      	str	r2, [r3, #24]
//CCCR.CCE and CCCR.INIT need to be set to 1 to change register config
//CCCR.CCE should be set/reset when CCCR.INIT = 1 so say 39.6.2.1


//We finish but resetting CCCR.INIT as per 39.6.2.1
CAN0_REGS->CAN_CCCR = CAN_CCCR_INIT_Msk;
 510:	619a      	str	r2, [r3, #24]

}
 512:	4770      	bx	lr

00000514 <CAN0Init>:


void CAN0Init(){

//Initiate CAN0 TX port
PORT_REGS->GROUP[0].PORT_PINCFG[22] |= PORT_PINCFG_PMUXEN_Msk;
 514:	4b0c      	ldr	r3, [pc, #48]	@ (548 <CAN0Init+0x34>)
 516:	f893 2056 	ldrb.w	r2, [r3, #86]	@ 0x56
 51a:	f042 0201 	orr.w	r2, r2, #1
 51e:	f883 2056 	strb.w	r2, [r3, #86]	@ 0x56
PORT_REGS->GROUP[0].PORT_PMUX[11] |= PORT_PMUX_PMUXE_I;    
 522:	f893 203b 	ldrb.w	r2, [r3, #59]	@ 0x3b
 526:	f042 0208 	orr.w	r2, r2, #8
 52a:	f883 203b 	strb.w	r2, [r3, #59]	@ 0x3b

//Initiate CAN0 RX port
PORT_REGS->GROUP[0].PORT_PINCFG[23] |= PORT_PINCFG_PMUXEN_Msk;
 52e:	f893 2057 	ldrb.w	r2, [r3, #87]	@ 0x57
 532:	f042 0201 	orr.w	r2, r2, #1
 536:	f883 2057 	strb.w	r2, [r3, #87]	@ 0x57
PORT_REGS->GROUP[0].PORT_PMUX[11] |= PORT_PMUX_PMUXO_I;    
 53a:	f893 203b 	ldrb.w	r2, [r3, #59]	@ 0x3b
 53e:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 542:	f883 203b 	strb.w	r2, [r3, #59]	@ 0x3b


 546:	4770      	bx	lr
 548:	41008000 	.word	0x41008000

0000054c <clkI2C>:
	//See portIni	
	
	//36.5.3 Clocks
	//Our I2C is connected to SERCOM2 so we need to configure the clocks for that
	//We need both core and slow generic clocks enabled
	GCLK_REGS->GCLK_PCHCTRL[SERCOM2_GCLK_ID_CORE] |= GCLK_PCHCTRL_CHEN_Msk;
 54c:	4a08      	ldr	r2, [pc, #32]	@ (570 <clkI2C+0x24>)
 54e:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
 552:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 556:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
	while((GCLK_REGS->GCLK_PCHCTRL[SERCOM2_GCLK_ID_CORE] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk){
 55a:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
 55e:	f013 0f40 	tst.w	r3, #64	@ 0x40
 562:	d0fa      	beq.n	55a <clkI2C+0xe>
		//wait for sync
	}//while	
	
	//Turn on Sercom2 in main clock
	MCLK_REGS->MCLK_APBBMASK |= MCLK_APBBMASK_SERCOM2_Msk;
 564:	4a03      	ldr	r2, [pc, #12]	@ (574 <clkI2C+0x28>)
 566:	6993      	ldr	r3, [r2, #24]
 568:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 56c:	6193      	str	r3, [r2, #24]


}//clkI2C
 56e:	4770      	bx	lr
 570:	40001c00 	.word	0x40001c00
 574:	40000800 	.word	0x40000800

00000578 <initI2C>:

void initI2C(){
	//36.6.2.1 Initialization 
	//This is done out of order and in the order of the cited source above. Not following the datasheet order
	//Ensure a clean register and set software reset bit
	SERCOM2_REGS->I2CM.SERCOM_CTRLA = SERCOM_I2CM_CTRLA_SWRST_Msk;
 578:	4b11      	ldr	r3, [pc, #68]	@ (5c0 <initI2C+0x48>)
 57a:	2201      	movs	r2, #1
 57c:	601a      	str	r2, [r3, #0]
	
	while((SERCOM2_REGS->I2CM.SERCOM_SYNCBUSY) != 0U){
 57e:	461a      	mov	r2, r3
 580:	69d3      	ldr	r3, [r2, #28]
 582:	2b00      	cmp	r3, #0
 584:	d1fc      	bne.n	580 <initI2C+0x8>

	}//while

	//We are lazy and want to enable smart mode to do auto ACK or NACK responses when DATA.DATA is read 36.6.3.2 Smart Mode

	SERCOM2_REGS->I2CM.SERCOM_CTRLB = SERCOM_I2CM_CTRLB_SMEN_Msk;
 586:	4b0e      	ldr	r3, [pc, #56]	@ (5c0 <initI2C+0x48>)
 588:	f44f 7280 	mov.w	r2, #256	@ 0x100
 58c:	605a      	str	r2, [r3, #4]
	
	while((SERCOM2_REGS->I2CM.SERCOM_SYNCBUSY) != 0U){
 58e:	461a      	mov	r2, r3
 590:	69d3      	ldr	r3, [r2, #28]
 592:	2b00      	cmp	r3, #0
 594:	d1fc      	bne.n	590 <initI2C+0x18>

	}//while
	

	//Set our BAUD rate 
	SERCOM2_REGS->I2CM.SERCOM_BAUD = I2C_BAUD; 
 596:	4b0a      	ldr	r3, [pc, #40]	@ (5c0 <initI2C+0x48>)
 598:	f44f 7280 	mov.w	r2, #256	@ 0x100
 59c:	60da      	str	r2, [r3, #12]
	
	//We will now turn on SERCOM2 in I2C host mode
	SERCOM2_REGS->I2CM.SERCOM_CTRLA = SERCOM_I2CM_CTRLA_ENABLE_Msk | SERCOM_I2CM_CTRLA_MODE_I2C_MASTER | SERCOM_I2CM_CTRLA_SPEED_STANDARD_AND_FAST_MODE | SERCOM_I2CM_CTRLA_SCLSM(1UL);
 59e:	4a09      	ldr	r2, [pc, #36]	@ (5c4 <initI2C+0x4c>)
 5a0:	601a      	str	r2, [r3, #0]
	
	
	while((SERCOM2_REGS->I2CM.SERCOM_SYNCBUSY) != 0U){
 5a2:	461a      	mov	r2, r3
 5a4:	69d3      	ldr	r3, [r2, #28]
 5a6:	2b00      	cmp	r3, #0
 5a8:	d1fc      	bne.n	5a4 <initI2C+0x2c>
		//But more importantly we are waiting for SYNCBUSY.ENABLE

	}//while
	
	//We now need to change the state of the SERCOM FSM as page on page 932 fig 36-4
	SERCOM2_REGS->I2CM.SERCOM_STATUS = (uint16_t)SERCOM_I2CM_STATUS_BUSSTATE(0X01UL);
 5aa:	4b05      	ldr	r3, [pc, #20]	@ (5c0 <initI2C+0x48>)
 5ac:	2210      	movs	r2, #16
 5ae:	835a      	strh	r2, [r3, #26]


	while((SERCOM2_REGS->I2CM.SERCOM_SYNCBUSY) != 0U){
 5b0:	461a      	mov	r2, r3
 5b2:	69d3      	ldr	r3, [r2, #28]
 5b4:	2b00      	cmp	r3, #0
 5b6:	d1fc      	bne.n	5b2 <initI2C+0x3a>
		//wait for sync of SYNCBUSY.SYSOP as we changed STATUS.BUSSTATE 

	}//while
	
	//let us enable all interrupts so we can check for error, and who is owner of the bus
	SERCOM2_REGS->I2CM.SERCOM_INTENSET = (uint8_t)SERCOM_I2CM_INTENSET_Msk;
 5b8:	4b01      	ldr	r3, [pc, #4]	@ (5c0 <initI2C+0x48>)
 5ba:	2283      	movs	r2, #131	@ 0x83
 5bc:	759a      	strb	r2, [r3, #22]



}//initI2C
 5be:	4770      	bx	lr
 5c0:	41012000 	.word	0x41012000
 5c4:	08000016 	.word	0x08000016

000005c8 <sercom2Init>:

void sercom2Init(){
    //I2C SDA on PORT_PA12
    PORT_REGS->GROUP[0].PORT_PINCFG[12] |= PORT_PINCFG_PMUXEN_Msk;
 5c8:	4b0c      	ldr	r3, [pc, #48]	@ (5fc <sercom2Init+0x34>)
 5ca:	f893 204c 	ldrb.w	r2, [r3, #76]	@ 0x4c
 5ce:	f042 0201 	orr.w	r2, r2, #1
 5d2:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c
    PORT_REGS->GROUP[0].PORT_PMUX[6] |= PORT_PMUX_PMUXE_C;
 5d6:	f893 2036 	ldrb.w	r2, [r3, #54]	@ 0x36
 5da:	f042 0202 	orr.w	r2, r2, #2
 5de:	f883 2036 	strb.w	r2, [r3, #54]	@ 0x36

    //I2C SCL on PORT_PA13
    PORT_REGS->GROUP[0].PORT_PINCFG[13] |= PORT_PINCFG_PMUXEN_Msk;
 5e2:	f893 204d 	ldrb.w	r2, [r3, #77]	@ 0x4d
 5e6:	f042 0201 	orr.w	r2, r2, #1
 5ea:	f883 204d 	strb.w	r2, [r3, #77]	@ 0x4d
    PORT_REGS->GROUP[0].PORT_PMUX[6] |= PORT_PMUX_PMUXO_C;
 5ee:	f893 2036 	ldrb.w	r2, [r3, #54]	@ 0x36
 5f2:	f042 0220 	orr.w	r2, r2, #32
 5f6:	f883 2036 	strb.w	r2, [r3, #54]	@ 0x36

}//sercom2Init
 5fa:	4770      	bx	lr
 5fc:	41008000 	.word	0x41008000

00000600 <i2cSndAddr>:
// i2cSndAddr
//
// PURPOSE:	This code sends the address of the i2c device 
//		shifted over and writes the required r/w bit
//------------------------------------------------------
void i2cSndAddr(uint8_t addr, bool dir){
 600:	b082      	sub	sp, #8
	
	volatile uint32_t regVal = (((uint32_t)(addr)) <<1U);
 602:	0040      	lsls	r0, r0, #1
 604:	9001      	str	r0, [sp, #4]
	
	if(dir){
 606:	b161      	cbz	r1, 622 <i2cSndAddr+0x22>
		//append a 1 to the regVal to do a read
		regVal = (regVal |(uint32_t)(1UL));
 608:	9b01      	ldr	r3, [sp, #4]
 60a:	f043 0301 	orr.w	r3, r3, #1
 60e:	9301      	str	r3, [sp, #4]
	
	}//else
	
	// implied else its a write and the 0 is fiiiine.
	
	SERCOM2_REGS->I2CM.SERCOM_ADDR = regVal;
 610:	9a01      	ldr	r2, [sp, #4]
 612:	4b05      	ldr	r3, [pc, #20]	@ (628 <i2cSndAddr+0x28>)
 614:	625a      	str	r2, [r3, #36]	@ 0x24

	while((SERCOM2_REGS->I2CM.SERCOM_SYNCBUSY) != 0U){
 616:	461a      	mov	r2, r3
 618:	69d3      	ldr	r3, [r2, #28]
 61a:	2b00      	cmp	r3, #0
 61c:	d1fc      	bne.n	618 <i2cSndAddr+0x18>
		
		//wait for sync of SYNCBUSY.SYSOP as we changed SERCOM.ADDR

	}//while

}//i2cSndAddr
 61e:	b002      	add	sp, #8
 620:	4770      	bx	lr
		regVal = (regVal |(uint32_t)(0UL));
 622:	9b01      	ldr	r3, [sp, #4]
 624:	9301      	str	r3, [sp, #4]
 626:	e7f3      	b.n	610 <i2cSndAddr+0x10>
 628:	41012000 	.word	0x41012000

0000062c <initTx>:
//	addr is the address of the REGISTER, bytes is how many bytes are being read/written, 
//	data is a pointer to a buffer for reading/writing, dir is the direction of the tx READ(true) WRITE(false)
// OUTPUT:
//	A I2C tx will be sent across the SERCOM bus
//------------------------------------------------------
void initTx(uint8_t addr, size_t bytes,volatile unsigned char *data, bool dir){
 62c:	b510      	push	{r4, lr}
 62e:	4604      	mov	r4, r0
	
	//make sure we are set to send ACKs not NAKCs if we previously transmitted
	SERCOM2_REGS->I2CM.SERCOM_CTRLB &= ~SERCOM_I2CM_CTRLB_ACKACT_Msk;
 630:	4a0b      	ldr	r2, [pc, #44]	@ (660 <initTx+0x34>)
 632:	6853      	ldr	r3, [r2, #4]
 634:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 638:	6053      	str	r3, [r2, #4]

	//Send gyro bus address wait happens in the function
	//In order to do a any tx type we first need to do a write request to write the data of the SUB address
	//See page 29 of the LSM9DS manual for more details on read/write operations
	i2cSndAddr(GYRO_I2C_AG, WRITE);
 63a:	2100      	movs	r1, #0
 63c:	206b      	movs	r0, #107	@ 0x6b
 63e:	f7ff ffdf 	bl	600 <i2cSndAddr>
	
	//Currently we have sent the ST, then SAD+W as required. We should get an ACK back (SAK) 

	while((SERCOM2_REGS->I2CM.SERCOM_SYNCBUSY) != 0U){
 642:	4a07      	ldr	r2, [pc, #28]	@ (660 <initTx+0x34>)
 644:	69d3      	ldr	r3, [r2, #28]
 646:	2b00      	cmp	r3, #0
 648:	d1fc      	bne.n	644 <initTx+0x18>
		
		//wait for sync of SYNCBUSY.SYSOP as we changed SERCOM.ADDR
	
	}//while
	
	while(SERCOM2_REGS->I2CM.SERCOM_INTFLAG == 0){
 64a:	4a05      	ldr	r2, [pc, #20]	@ (660 <initTx+0x34>)
 64c:	7e13      	ldrb	r3, [r2, #24]
 64e:	2b00      	cmp	r3, #0
 650:	d0fc      	beq.n	64c <initTx+0x20>
		
	}//while

	//Now we send the address as data to the gyro
	//we DO NOT shift this one as we can use the MSB to set auto increment
	SERCOM2_REGS->I2CM.SERCOM_DATA = addr;
 652:	4b03      	ldr	r3, [pc, #12]	@ (660 <initTx+0x34>)
 654:	629c      	str	r4, [r3, #40]	@ 0x28
	
	while((SERCOM2_REGS->I2CM.SERCOM_SYNCBUSY) != 0U){
 656:	461a      	mov	r2, r3
 658:	69d3      	ldr	r3, [r2, #28]
 65a:	2b00      	cmp	r3, #0
 65c:	d1fc      	bne.n	658 <initTx+0x2c>

	}//while
	
	

}//initTx
 65e:	bd10      	pop	{r4, pc}
 660:	41012000 	.word	0x41012000

00000664 <initRead>:

void initRead(uint8_t addr, size_t bytes,volatile unsigned char *data){
 664:	b530      	push	{r4, r5, lr}
 666:	b083      	sub	sp, #12
 668:	460c      	mov	r4, r1
 66a:	4615      	mov	r5, r2
	volatile size_t count = 0;
 66c:	2300      	movs	r3, #0
 66e:	9301      	str	r3, [sp, #4]
	
	initTx(addr,bytes,data,READ);
 670:	2301      	movs	r3, #1
 672:	f7ff ffdb 	bl	62c <initTx>
	
	//exaimine page 29 of the LSM9DS1 datasheet.
	//We need to send the gyro address again with a re-start (SR then SAD+R)  
	i2cSndAddr(GYRO_I2C_AG, READ);
 676:	2101      	movs	r1, #1
 678:	206b      	movs	r0, #107	@ 0x6b
 67a:	f7ff ffc1 	bl	600 <i2cSndAddr>

		while((SERCOM2_REGS->I2CM.SERCOM_INTFLAG) == 0U){
 67e:	4a13      	ldr	r2, [pc, #76]	@ (6cc <initRead+0x68>)
 680:	7e13      	ldrb	r3, [r2, #24]
 682:	2b00      	cmp	r3, #0
 684:	d0fc      	beq.n	680 <initRead+0x1c>
		
			//wait for sync of SYNCBUSY.SYSOP to ensure we are not doing anything on the bus

		}//while
	while(count < bytes){
 686:	9b01      	ldr	r3, [sp, #4]
 688:	429c      	cmp	r4, r3
 68a:	d910      	bls.n	6ae <initRead+0x4a>
		
		while((SERCOM2_REGS->I2CM.SERCOM_INTFLAG) == 0U){
 68c:	4b0f      	ldr	r3, [pc, #60]	@ (6cc <initRead+0x68>)
 68e:	7e18      	ldrb	r0, [r3, #24]
 690:	2800      	cmp	r0, #0
 692:	d0fc      	beq.n	68e <initRead+0x2a>
		
			//wait for sync of SYNCBUSY.SYSOP to ensure we are not doing anything on the bus

		}//while
		while(SERCOM2_REGS->I2CM.SERCOM_SYNCBUSY !=0U){
 694:	69d8      	ldr	r0, [r3, #28]
 696:	2800      	cmp	r0, #0
 698:	d1fc      	bne.n	694 <initRead+0x30>

		}//while
		 data[count] = (uint8_t)SERCOM2_REGS->I2CM.SERCOM_DATA;
 69a:	6a98      	ldr	r0, [r3, #40]	@ 0x28
 69c:	9a01      	ldr	r2, [sp, #4]
 69e:	b2c0      	uxtb	r0, r0
 6a0:	54a8      	strb	r0, [r5, r2]

		count ++;
 6a2:	9801      	ldr	r0, [sp, #4]
 6a4:	3001      	adds	r0, #1
 6a6:	9001      	str	r0, [sp, #4]
	while(count < bytes){
 6a8:	9a01      	ldr	r2, [sp, #4]
 6aa:	42a2      	cmp	r2, r4
 6ac:	d3ef      	bcc.n	68e <initRead+0x2a>

	}//while
	
	if(count == bytes){
 6ae:	9b01      	ldr	r3, [sp, #4]
 6b0:	42a3      	cmp	r3, r4
 6b2:	d001      	beq.n	6b8 <initRead+0x54>

		}//while
	}//if
	

}//initRead
 6b4:	b003      	add	sp, #12
 6b6:	bd30      	pop	{r4, r5, pc}
		SERCOM2_REGS->I2CM.SERCOM_CTRLB |= SERCOM_I2CM_CTRLB_ACKACT_Msk | SERCOM_I2CM_CTRLB_CMD(3UL);
 6b8:	4a04      	ldr	r2, [pc, #16]	@ (6cc <initRead+0x68>)
 6ba:	6853      	ldr	r3, [r2, #4]
 6bc:	f443 23e0 	orr.w	r3, r3, #458752	@ 0x70000
 6c0:	6053      	str	r3, [r2, #4]
		while((SERCOM2_REGS->I2CM.SERCOM_SYNCBUSY) != 0U){
 6c2:	69d3      	ldr	r3, [r2, #28]
 6c4:	2b00      	cmp	r3, #0
 6c6:	d1fc      	bne.n	6c2 <initRead+0x5e>
 6c8:	e7f4      	b.n	6b4 <initRead+0x50>
 6ca:	bf00      	nop
 6cc:	41012000 	.word	0x41012000

000006d0 <initWrite>:
//	addr is the address of the REGISTER, bytes is how many bytes are being read/written, 
//	data is a pointer to a buffer for reading/writing
// OUTPUT:
//	A I2C write tx will be sent across the SERCOM bus
//------------------------------------------------------
void initWrite(uint8_t addr, size_t bytes,volatile unsigned char *data){
 6d0:	b538      	push	{r3, r4, r5, lr}
 6d2:	460d      	mov	r5, r1
 6d4:	4614      	mov	r4, r2
	size_t count = 0;	
	initTx(addr,bytes,data,WRITE);
 6d6:	2300      	movs	r3, #0
 6d8:	f7ff ffa8 	bl	62c <initTx>
	
	while( count < bytes){
 6dc:	b15d      	cbz	r5, 6f6 <initWrite+0x26>
 6de:	4620      	mov	r0, r4
 6e0:	1961      	adds	r1, r4, r5
		
		while((SERCOM2_REGS->I2CM.SERCOM_INTFLAG) == 0U){
 6e2:	4a09      	ldr	r2, [pc, #36]	@ (708 <initWrite+0x38>)
 6e4:	7e13      	ldrb	r3, [r2, #24]
 6e6:	2b00      	cmp	r3, #0
 6e8:	d0fc      	beq.n	6e4 <initWrite+0x14>
		
			//wait for sync of SYNCBUSY.SYSOP to ensure we are not doing anything on the bus

		}//while
		 
		SERCOM2_REGS->I2CM.SERCOM_DATA = data[count];
 6ea:	f810 3b01 	ldrb.w	r3, [r0], #1
 6ee:	b2db      	uxtb	r3, r3
 6f0:	6293      	str	r3, [r2, #40]	@ 0x28
	while( count < bytes){
 6f2:	4288      	cmp	r0, r1
 6f4:	d1f6      	bne.n	6e4 <initWrite+0x14>

	}//while	


	//Don't need to NACK the gyro according to its data sheet just send a stop
	SERCOM2_REGS->I2CM.SERCOM_CTRLB |= SERCOM_I2CM_CTRLB_CMD(3UL);
 6f6:	4a04      	ldr	r2, [pc, #16]	@ (708 <initWrite+0x38>)
 6f8:	6853      	ldr	r3, [r2, #4]
 6fa:	f443 3340 	orr.w	r3, r3, #196608	@ 0x30000
 6fe:	6053      	str	r3, [r2, #4]
		

	while((SERCOM2_REGS->I2CM.SERCOM_SYNCBUSY) != 0U){
 700:	69d3      	ldr	r3, [r2, #28]
 702:	2b00      	cmp	r3, #0
 704:	d1fc      	bne.n	700 <initWrite+0x30>
		

	}//while
	count = 0;
}//initWrite
 706:	bd38      	pop	{r3, r4, r5, pc}
 708:	41012000 	.word	0x41012000

0000070c <accelOnlyMode>:

void accelOnlyMode(){
 70c:	b500      	push	{lr}
 70e:	b091      	sub	sp, #68	@ 0x44
	//for some reason unknown to me you have to write 
	//this control register first or else writting
	//the next will get rid of the aut inc bit
	//big shrug
	uint16_t writeBuffer[WRITE_BUF_SIZE];
	writeBuffer[0] = CTRL_REG8_IF_ADD_INC_Msk;
 710:	2304      	movs	r3, #4
 712:	f8ad 3000 	strh.w	r3, [sp]
	initWrite(CTRL_REG8,1,writeBuffer);
 716:	466a      	mov	r2, sp
 718:	2101      	movs	r1, #1
 71a:	2022      	movs	r0, #34	@ 0x22
 71c:	f7ff ffd8 	bl	6d0 <initWrite>
	
	while((SERCOM2_REGS->I2CM.SERCOM_INTFLAG) == 0U){
 720:	4a07      	ldr	r2, [pc, #28]	@ (740 <accelOnlyMode+0x34>)
 722:	7e13      	ldrb	r3, [r2, #24]
 724:	2b00      	cmp	r3, #0
 726:	d0fc      	beq.n	722 <accelOnlyMode+0x16>
		
		//wait for sync of SYNCBUSY.SYSOP to ensure we are not doing anything on the bus

	}//while

	writeBuffer[0] = CTRL_REG6_XL_50HZ_Msk;
 728:	2340      	movs	r3, #64	@ 0x40
 72a:	f8ad 3000 	strh.w	r3, [sp]
	initWrite(CTRL_REG6_XL,1,writeBuffer);
 72e:	466a      	mov	r2, sp
 730:	2101      	movs	r1, #1
 732:	2020      	movs	r0, #32
 734:	f7ff ffcc 	bl	6d0 <initWrite>

}//accelOnlyMode
 738:	b011      	add	sp, #68	@ 0x44
 73a:	f85d fb04 	ldr.w	pc, [sp], #4
 73e:	bf00      	nop
 740:	41012000 	.word	0x41012000

00000744 <sampleXL>:

void sampleXL(){
 744:	b500      	push	{lr}
 746:	f5ad 7d7b 	sub.w	sp, sp, #1004	@ 0x3ec
	int zVal = 0;
	int yVal = 0; 

	uint8_t readBuffer[READ_BUF_SIZE];
	//get the values from the gyro and put into the read buffer
	initRead((OUT_X_XL_START|AUTO_INC_Msk),6,readBuffer);
 74a:	466a      	mov	r2, sp
 74c:	2106      	movs	r1, #6
 74e:	20a8      	movs	r0, #168	@ 0xa8
 750:	f7ff ff88 	bl	664 <initRead>
	yWindow[curr] = yVal;
	zWindow[curr] = zVal;
	
	curr = (curr+1)%WINDOW_SIZE;
*/
 754:	f50d 7d7b 	add.w	sp, sp, #1004	@ 0x3ec
 758:	f85d fb04 	ldr.w	pc, [sp], #4

0000075c <initAllPorts>:
void initAllPorts(){
 75c:	b508      	push	{r3, lr}
  PORT_REGS->GROUP[0].PORT_DIRSET = PORT_PA14;
 75e:	4b06      	ldr	r3, [pc, #24]	@ (778 <initAllPorts+0x1c>)
 760:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 764:	609a      	str	r2, [r3, #8]
  PORT_REGS->GROUP[0].PORT_OUTSET = PORT_PA14;
 766:	619a      	str	r2, [r3, #24]
  port15Init(); //init button ports
 768:	f7ff fe9e 	bl	4a8 <port15Init>
  sercom2Init(); //init sercom2 -> i2c ports
 76c:	f7ff ff2c 	bl	5c8 <sercom2Init>
  CAN0Init(); //init CAN0 ports
 770:	f7ff fed0 	bl	514 <CAN0Init>
}//initAllPorts
 774:	bd08      	pop	{r3, pc}
 776:	bf00      	nop
 778:	41008000 	.word	0x41008000

0000077c <initAllClks>:
void initAllClks(){
 77c:	b508      	push	{r3, lr}
  clkButton();
 77e:	f7ff fe6b 	bl	458 <clkButton>
  clkI2C();
 782:	f7ff fee3 	bl	54c <clkI2C>
  clkCAN();
 786:	f7ff fea9 	bl	4dc <clkCAN>
}//initAllClks
 78a:	bd08      	pop	{r3, pc}

0000078c <heartInit>:

void heartInit(){
  // setup the main clock/CPU clock to run at 120MHz

  // set generator 2 to use DFLL48M as source; with a divider of 48 that gives us 1MHz
  GCLK_REGS->GCLK_GENCTRL[2] = GCLK_GENCTRL_DIV(48) | GCLK_GENCTRL_SRC_DFLL | GCLK_GENCTRL_GENEN_Msk;
 78c:	4b24      	ldr	r3, [pc, #144]	@ (820 <heartInit+0x94>)
 78e:	4a25      	ldr	r2, [pc, #148]	@ (824 <heartInit+0x98>)
 790:	629a      	str	r2, [r3, #40]	@ 0x28
  while ((GCLK_REGS->GCLK_SYNCBUSY & GCLK_SYNCBUSY_GENCTRL_GCLK2) == GCLK_SYNCBUSY_GENCTRL_GCLK2)
 792:	461a      	mov	r2, r3
 794:	6853      	ldr	r3, [r2, #4]
 796:	f013 0f10 	tst.w	r3, #16
 79a:	d1fb      	bne.n	794 <heartInit+0x8>
    ; /* Wait for synchronization */

  // set DPLL0 peripheral to use generator 2 as its clock
  // see page 156 of data sheet for GCLK array offsets
  GCLK_REGS->GCLK_PCHCTRL[1] = GCLK_PCHCTRL_GEN_GCLK2 | GCLK_PCHCTRL_CHEN_Msk;
 79c:	4b20      	ldr	r3, [pc, #128]	@ (820 <heartInit+0x94>)
 79e:	2242      	movs	r2, #66	@ 0x42
 7a0:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  while ((GCLK_REGS->GCLK_PCHCTRL[1] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
 7a4:	461a      	mov	r2, r3
 7a6:	f8d2 3084 	ldr.w	r3, [r2, #132]	@ 0x84
 7aa:	f013 0f40 	tst.w	r3, #64	@ 0x40
 7ae:	d0fa      	beq.n	7a6 <heartInit+0x1a>
    ; /* Wait for synchronization */

  // DPLL in integer mode: multiply generator clk by 120, giving us 120MHz
  OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLCTRLB = OSCCTRL_DPLLCTRLB_FILTER(0) | OSCCTRL_DPLLCTRLB_LTIME(0) | OSCCTRL_DPLLCTRLB_REFCLK(0);
 7b0:	4b1d      	ldr	r3, [pc, #116]	@ (828 <heartInit+0x9c>)
 7b2:	2200      	movs	r2, #0
 7b4:	639a      	str	r2, [r3, #56]	@ 0x38
  OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLRATIO = OSCCTRL_DPLLRATIO_LDRFRAC(0) | OSCCTRL_DPLLRATIO_LDR(119);
 7b6:	2277      	movs	r2, #119	@ 0x77
 7b8:	635a      	str	r2, [r3, #52]	@ 0x34
  while ((OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLSYNCBUSY & OSCCTRL_DPLLSYNCBUSY_DPLLRATIO_Msk) == OSCCTRL_DPLLSYNCBUSY_DPLLRATIO_Msk)
 7ba:	461a      	mov	r2, r3
 7bc:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
 7be:	f013 0f04 	tst.w	r3, #4
 7c2:	d1fb      	bne.n	7bc <heartInit+0x30>
    ; /* Wait for synchronization */

  // Enable DPLL0
  OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLCTRLA = OSCCTRL_DPLLCTRLA_ENABLE_Msk;
 7c4:	4b18      	ldr	r3, [pc, #96]	@ (828 <heartInit+0x9c>)
 7c6:	2202      	movs	r2, #2
 7c8:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
  while ((OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLSYNCBUSY & OSCCTRL_DPLLSYNCBUSY_ENABLE_Msk) == OSCCTRL_DPLLSYNCBUSY_ENABLE_Msk)
 7cc:	461a      	mov	r2, r3
 7ce:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
 7d0:	f013 0f02 	tst.w	r3, #2
 7d4:	d1fb      	bne.n	7ce <heartInit+0x42>
    ; /* Wait for synchronization */

  while ((OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLSTATUS & (OSCCTRL_DPLLSTATUS_LOCK_Msk | OSCCTRL_DPLLSTATUS_CLKRDY_Msk)) !=
 7d6:	4a14      	ldr	r2, [pc, #80]	@ (828 <heartInit+0x9c>)
 7d8:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 7da:	f003 0303 	and.w	r3, r3, #3
 7de:	2b03      	cmp	r3, #3
 7e0:	d1fa      	bne.n	7d8 <heartInit+0x4c>
         (OSCCTRL_DPLLSTATUS_LOCK_Msk | OSCCTRL_DPLLSTATUS_CLKRDY_Msk))
    ; /* Wait for ready state */

  // define our main generic clock, which drives everything, to be 120MHz from the PLL
  MCLK_REGS->MCLK_CPUDIV = MCLK_CPUDIV_DIV_DIV1;
 7e2:	4b12      	ldr	r3, [pc, #72]	@ (82c <heartInit+0xa0>)
 7e4:	2201      	movs	r2, #1
 7e6:	715a      	strb	r2, [r3, #5]
  while ((MCLK_REGS->MCLK_INTFLAG & MCLK_INTFLAG_CKRDY_Msk) != MCLK_INTFLAG_CKRDY_Msk)
 7e8:	461a      	mov	r2, r3
 7ea:	78d3      	ldrb	r3, [r2, #3]
 7ec:	f013 0f01 	tst.w	r3, #1
 7f0:	d0fb      	beq.n	7ea <heartInit+0x5e>
    ; /* Wait for main clock to be ready */

  GCLK_REGS->GCLK_GENCTRL[0] = GCLK_GENCTRL_DIVSEL_DIV1 | GCLK_GENCTRL_SRC_DPLL0 | GCLK_GENCTRL_GENEN_Msk;
 7f2:	4b0b      	ldr	r3, [pc, #44]	@ (820 <heartInit+0x94>)
 7f4:	f240 1207 	movw	r2, #263	@ 0x107
 7f8:	621a      	str	r2, [r3, #32]
  while ((GCLK_REGS->GCLK_SYNCBUSY & GCLK_SYNCBUSY_GENCTRL_GCLK0) == GCLK_SYNCBUSY_GENCTRL_GCLK0)
 7fa:	461a      	mov	r2, r3
 7fc:	6853      	ldr	r3, [r2, #4]
 7fe:	f013 0f04 	tst.w	r3, #4
 802:	d1fb      	bne.n	7fc <heartInit+0x70>
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 804:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 808:	4a09      	ldr	r2, [pc, #36]	@ (830 <heartInit+0xa4>)
 80a:	615a      	str	r2, [r3, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80c:	4a09      	ldr	r2, [pc, #36]	@ (834 <heartInit+0xa8>)
 80e:	21e0      	movs	r1, #224	@ 0xe0
 810:	f882 1023 	strb.w	r1, [r2, #35]	@ 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 814:	2200      	movs	r2, #0
 816:	619a      	str	r2, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 818:	2207      	movs	r2, #7
 81a:	611a      	str	r2, [r3, #16]

  // have to enable the interrupt line in the system level REG
  NVIC_EnableIRQ(SysTick_IRQn);

  SysTick_Config(MS_TICKS);
}
 81c:	4770      	bx	lr
 81e:	bf00      	nop
 820:	40001c00 	.word	0x40001c00
 824:	00300106 	.word	0x00300106
 828:	40001000 	.word	0x40001000
 82c:	40000800 	.word	0x40000800
 830:	0001d4bf 	.word	0x0001d4bf
 834:	e000ed00 	.word	0xe000ed00

00000838 <initAll>:
void initAll(){
 838:	b508      	push	{r3, lr}
  heartInit();
 83a:	f7ff ffa7 	bl	78c <heartInit>
  initAllClks();
 83e:	f7ff ff9d 	bl	77c <initAllClks>
  initAllPorts();
 842:	f7ff ff8b 	bl	75c <initAllPorts>
  initI2C();
 846:	f7ff fe97 	bl	578 <initI2C>
  initButton();
 84a:	f7ff fe13 	bl	474 <initButton>
  initCAN();
 84e:	f7ff fe5b 	bl	508 <initCAN>
  accelOnlyMode();
 852:	f7ff ff5b 	bl	70c <accelOnlyMode>
}
 856:	bd08      	pop	{r3, pc}

00000858 <SysTick_Handler>:


// Fires every 1ms
void SysTick_Handler(){
  msCount++;
 858:	4a02      	ldr	r2, [pc, #8]	@ (864 <SysTick_Handler+0xc>)
 85a:	6813      	ldr	r3, [r2, #0]
 85c:	3301      	adds	r3, #1
 85e:	6013      	str	r3, [r2, #0]
}
 860:	4770      	bx	lr
 862:	bf00      	nop
 864:	20000020 	.word	0x20000020

00000868 <EIC_EXTINT_15_Handler>:

// ISR for  external interrupt 15, add processing code as required...
void EIC_EXTINT_15_Handler(){
  PORT_REGS->GROUP[0].PORT_OUTTGL = PORT_PA14;
 868:	4b04      	ldr	r3, [pc, #16]	@ (87c <EIC_EXTINT_15_Handler+0x14>)
 86a:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 86e:	61da      	str	r2, [r3, #28]
  // clear the interrupt! and go to the next operating mode
  EIC_REGS->EIC_INTFLAG |= EXTINT15_MASK;
 870:	4a03      	ldr	r2, [pc, #12]	@ (880 <EIC_EXTINT_15_Handler+0x18>)
 872:	6953      	ldr	r3, [r2, #20]
 874:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 878:	6153      	str	r3, [r2, #20]
}
 87a:	4770      	bx	lr
 87c:	41008000 	.word	0x41008000
 880:	40002800 	.word	0x40002800

00000884 <main>:
  dbg_write_str("beforee");
  PORT_REGS->GROUP[0].PORT_OUTTGL = PORT_PA14;
  dbg_write_str("afterr");
}

int main(void){
 884:	b570      	push	{r4, r5, r6, lr}
 886:	4b19      	ldr	r3, [pc, #100]	@ (8ec <main+0x68>)



#ifndef NDEBUG
  for (int i = 0; i < DEBUG_WAIT; i++);
 888:	3b01      	subs	r3, #1
 88a:	d1fd      	bne.n	888 <main+0x4>

  // enable cache
  // tradeoff: +: really helps with repeated code/data (like when doing animations in a game)
  //           -: results in non-deterministic run-times
  //           +: there *is* a way to lock lines of cache to keep hard deadline code/data pinned in the cache
  if ((CMCC_REGS->CMCC_SR & CMCC_SR_CSTS_Msk) == 0)
 88c:	4b18      	ldr	r3, [pc, #96]	@ (8f0 <main+0x6c>)
 88e:	68db      	ldr	r3, [r3, #12]
 890:	f013 0f01 	tst.w	r3, #1
 894:	d102      	bne.n	89c <main+0x18>
    CMCC_REGS->CMCC_CTRL = CMCC_CTRL_CEN_Msk;
 896:	4b16      	ldr	r3, [pc, #88]	@ (8f0 <main+0x6c>)
 898:	2201      	movs	r2, #1
 89a:	609a      	str	r2, [r3, #8]

  // sleep to idle (wake on interrupts)
  PM_REGS->PM_SLEEPCFG |= PM_SLEEPCFG_SLEEPMODE_IDLE;
 89c:	4a15      	ldr	r2, [pc, #84]	@ (8f4 <main+0x70>)
 89e:	7853      	ldrb	r3, [r2, #1]
 8a0:	f043 0302 	orr.w	r3, r3, #2
 8a4:	7053      	strb	r3, [r2, #1]

  initAll();
 8a6:	f7ff ffc7 	bl	838 <initAll>
  \details Enables IRQ interrupts by clearing special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8aa:	b662      	cpsie	i
  // we want interrupts!
  __enable_irq();

  // some example logging calls
#ifndef NDEBUG
  dbg_write_str("~~~DEBUG ENABLED~~~\n");
 8ac:	4812      	ldr	r0, [pc, #72]	@ (8f8 <main+0x74>)
 8ae:	f7ff fd95 	bl	3dc <dbg_write_str>

  static const unsigned char test_u8[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0XDD, 0xEE, 0xFF};
  dbg_write_u8(test_u8, 16);
  */
#endif
  PORT_REGS->GROUP[0].PORT_OUTTGL = PORT_PA14;
 8b2:	4b12      	ldr	r3, [pc, #72]	@ (8fc <main+0x78>)
 8b4:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 8b8:	61da      	str	r2, [r3, #28]

    // demo an assertion firing into the debugger
    // assert(msCount != 250);

    // TODO: make proper task scheduling!
    if ((msCount % LED_FLASH_MS) == 0){
 8ba:	4c11      	ldr	r4, [pc, #68]	@ (900 <main+0x7c>)
 8bc:	4d11      	ldr	r5, [pc, #68]	@ (904 <main+0x80>)
      PORT_REGS->GROUP[0].PORT_OUTTGL = PORT_PA14;
 8be:	461e      	mov	r6, r3
 8c0:	e008      	b.n	8d4 <main+0x50>
 8c2:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
 8c6:	61f3      	str	r3, [r6, #28]
      #ifndef NDEBUG
        dbg_write_u32(&msCount, 1);
 8c8:	2101      	movs	r1, #1
 8ca:	4620      	mov	r0, r4
 8cc:	f7ff fd74 	bl	3b8 <dbg_write_u32>
      #endif
      sampleXL();
 8d0:	f7ff ff38 	bl	744 <sampleXL>
    __WFI();
 8d4:	bf30      	wfi
    if ((msCount % LED_FLASH_MS) == 0){
 8d6:	6823      	ldr	r3, [r4, #0]
 8d8:	fba5 1203 	umull	r1, r2, r5, r3
 8dc:	0912      	lsrs	r2, r2, #4
 8de:	21fa      	movs	r1, #250	@ 0xfa
 8e0:	fb01 3312 	mls	r3, r1, r2, r3
 8e4:	2b00      	cmp	r3, #0
 8e6:	d0ec      	beq.n	8c2 <main+0x3e>
     
    }
    else if ((msCount % GYRO_CHECK_MS) == 0){
 8e8:	6823      	ldr	r3, [r4, #0]
 8ea:	e7f3      	b.n	8d4 <main+0x50>
 8ec:	00989680 	.word	0x00989680
 8f0:	41006000 	.word	0x41006000
 8f4:	40000400 	.word	0x40000400
 8f8:	00000a54 	.word	0x00000a54
 8fc:	41008000 	.word	0x41008000
 900:	20000020 	.word	0x20000020
 904:	10624dd3 	.word	0x10624dd3

00000908 <register_fini>:
 908:	4b02      	ldr	r3, [pc, #8]	@ (914 <register_fini+0xc>)
 90a:	b113      	cbz	r3, 912 <register_fini+0xa>
 90c:	4802      	ldr	r0, [pc, #8]	@ (918 <register_fini+0x10>)
 90e:	f000 b845 	b.w	99c <atexit>
 912:	4770      	bx	lr
 914:	00000000 	.word	0x00000000
 918:	0000096d 	.word	0x0000096d

0000091c <__libc_init_array>:
 91c:	b570      	push	{r4, r5, r6, lr}
 91e:	4b0f      	ldr	r3, [pc, #60]	@ (95c <__libc_init_array+0x40>)
 920:	4d0f      	ldr	r5, [pc, #60]	@ (960 <__libc_init_array+0x44>)
 922:	42ab      	cmp	r3, r5
 924:	eba3 0605 	sub.w	r6, r3, r5
 928:	d007      	beq.n	93a <__libc_init_array+0x1e>
 92a:	10b6      	asrs	r6, r6, #2
 92c:	2400      	movs	r4, #0
 92e:	f855 3b04 	ldr.w	r3, [r5], #4
 932:	3401      	adds	r4, #1
 934:	4798      	blx	r3
 936:	42a6      	cmp	r6, r4
 938:	d8f9      	bhi.n	92e <__libc_init_array+0x12>
 93a:	f000 f897 	bl	a6c <_init>
 93e:	4d09      	ldr	r5, [pc, #36]	@ (964 <__libc_init_array+0x48>)
 940:	4b09      	ldr	r3, [pc, #36]	@ (968 <__libc_init_array+0x4c>)
 942:	1b5e      	subs	r6, r3, r5
 944:	42ab      	cmp	r3, r5
 946:	ea4f 06a6 	mov.w	r6, r6, asr #2
 94a:	d006      	beq.n	95a <__libc_init_array+0x3e>
 94c:	2400      	movs	r4, #0
 94e:	f855 3b04 	ldr.w	r3, [r5], #4
 952:	3401      	adds	r4, #1
 954:	4798      	blx	r3
 956:	42a6      	cmp	r6, r4
 958:	d8f9      	bhi.n	94e <__libc_init_array+0x32>
 95a:	bd70      	pop	{r4, r5, r6, pc}
 95c:	00000a78 	.word	0x00000a78
 960:	00000a78 	.word	0x00000a78
 964:	00000a78 	.word	0x00000a78
 968:	00000a80 	.word	0x00000a80

0000096c <__libc_fini_array>:
 96c:	b538      	push	{r3, r4, r5, lr}
 96e:	4d07      	ldr	r5, [pc, #28]	@ (98c <__libc_fini_array+0x20>)
 970:	4c07      	ldr	r4, [pc, #28]	@ (990 <__libc_fini_array+0x24>)
 972:	1b2c      	subs	r4, r5, r4
 974:	10a4      	asrs	r4, r4, #2
 976:	d005      	beq.n	984 <__libc_fini_array+0x18>
 978:	3c01      	subs	r4, #1
 97a:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 97e:	4798      	blx	r3
 980:	2c00      	cmp	r4, #0
 982:	d1f9      	bne.n	978 <__libc_fini_array+0xc>
 984:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 988:	f000 b87a 	b.w	a80 <_fini>
 98c:	00000a90 	.word	0x00000a90
 990:	00000a8c 	.word	0x00000a8c

00000994 <__retarget_lock_acquire_recursive>:
 994:	4770      	bx	lr
 996:	bf00      	nop

00000998 <__retarget_lock_release_recursive>:
 998:	4770      	bx	lr
 99a:	bf00      	nop

0000099c <atexit>:
 99c:	2300      	movs	r3, #0
 99e:	4601      	mov	r1, r0
 9a0:	461a      	mov	r2, r3
 9a2:	4618      	mov	r0, r3
 9a4:	f000 b800 	b.w	9a8 <__register_exitproc>

000009a8 <__register_exitproc>:
 9a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 9ac:	4d1b      	ldr	r5, [pc, #108]	@ (a1c <__register_exitproc+0x74>)
 9ae:	4606      	mov	r6, r0
 9b0:	6828      	ldr	r0, [r5, #0]
 9b2:	4698      	mov	r8, r3
 9b4:	460f      	mov	r7, r1
 9b6:	4691      	mov	r9, r2
 9b8:	f7ff ffec 	bl	994 <__retarget_lock_acquire_recursive>
 9bc:	4b18      	ldr	r3, [pc, #96]	@ (a20 <__register_exitproc+0x78>)
 9be:	681c      	ldr	r4, [r3, #0]
 9c0:	b31c      	cbz	r4, a0a <__register_exitproc+0x62>
 9c2:	6828      	ldr	r0, [r5, #0]
 9c4:	6865      	ldr	r5, [r4, #4]
 9c6:	2d1f      	cmp	r5, #31
 9c8:	dc22      	bgt.n	a10 <__register_exitproc+0x68>
 9ca:	b94e      	cbnz	r6, 9e0 <__register_exitproc+0x38>
 9cc:	1c6b      	adds	r3, r5, #1
 9ce:	3502      	adds	r5, #2
 9d0:	6063      	str	r3, [r4, #4]
 9d2:	f844 7025 	str.w	r7, [r4, r5, lsl #2]
 9d6:	f7ff ffdf 	bl	998 <__retarget_lock_release_recursive>
 9da:	2000      	movs	r0, #0
 9dc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 9e0:	eb04 0185 	add.w	r1, r4, r5, lsl #2
 9e4:	2301      	movs	r3, #1
 9e6:	f8c1 9088 	str.w	r9, [r1, #136]	@ 0x88
 9ea:	f8d4 2188 	ldr.w	r2, [r4, #392]	@ 0x188
 9ee:	40ab      	lsls	r3, r5
 9f0:	431a      	orrs	r2, r3
 9f2:	2e02      	cmp	r6, #2
 9f4:	f8c4 2188 	str.w	r2, [r4, #392]	@ 0x188
 9f8:	f8c1 8108 	str.w	r8, [r1, #264]	@ 0x108
 9fc:	d1e6      	bne.n	9cc <__register_exitproc+0x24>
 9fe:	f8d4 218c 	ldr.w	r2, [r4, #396]	@ 0x18c
 a02:	431a      	orrs	r2, r3
 a04:	f8c4 218c 	str.w	r2, [r4, #396]	@ 0x18c
 a08:	e7e0      	b.n	9cc <__register_exitproc+0x24>
 a0a:	4c06      	ldr	r4, [pc, #24]	@ (a24 <__register_exitproc+0x7c>)
 a0c:	601c      	str	r4, [r3, #0]
 a0e:	e7d8      	b.n	9c2 <__register_exitproc+0x1a>
 a10:	f7ff ffc2 	bl	998 <__retarget_lock_release_recursive>
 a14:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 a18:	e7e0      	b.n	9dc <__register_exitproc+0x34>
 a1a:	bf00      	nop
 a1c:	20000000 	.word	0x20000000
 a20:	20000024 	.word	0x20000024
 a24:	2000002c 	.word	0x2000002c
 a28:	65737341 	.word	0x65737341
 a2c:	6f697472 	.word	0x6f697472
 a30:	0027206e 	.word	0x0027206e
 a34:	61662027 	.word	0x61662027
 a38:	64656c69 	.word	0x64656c69
 a3c:	206e6920 	.word	0x206e6920
 a40:	00000000 	.word	0x00000000
 a44:	6f666562 	.word	0x6f666562
 a48:	00656572 	.word	0x00656572
 a4c:	65746661 	.word	0x65746661
 a50:	00007272 	.word	0x00007272
 a54:	447e7e7e 	.word	0x447e7e7e
 a58:	47554245 	.word	0x47554245
 a5c:	414e4520 	.word	0x414e4520
 a60:	44454c42 	.word	0x44454c42
 a64:	0a7e7e7e 	.word	0x0a7e7e7e
 a68:	00000000 	.word	0x00000000

00000a6c <_init>:
 a6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 a6e:	bf00      	nop
 a70:	bcf8      	pop	{r3, r4, r5, r6, r7}
 a72:	bc08      	pop	{r3}
 a74:	469e      	mov	lr, r3
 a76:	4770      	bx	lr

00000a78 <__init_array_start>:
 a78:	00000909 	.word	0x00000909

00000a7c <__frame_dummy_init_array_entry>:
 a7c:	000002c9                                ....

00000a80 <_fini>:
 a80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 a82:	bf00      	nop
 a84:	bcf8      	pop	{r3, r4, r5, r6, r7}
 a86:	bc08      	pop	{r3}
 a88:	469e      	mov	lr, r3
 a8a:	4770      	bx	lr

00000a8c <__do_global_dtors_aux_fini_array_entry>:
 a8c:	02a1 0000                                   ....
