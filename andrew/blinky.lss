
blinky.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000009e0  00000000  00000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000004  20000000  000009e0  00002000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  00002004  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  00002004  2**0
                  CONTENTS
  4 .bss          000001bc  20000004  000009e4  00002004  2**2
                  ALLOC
  5 .stack        00010000  200001c0  00000ba0  00002004  2**0
                  ALLOC
  6 .ARM.attributes 0000002a  00000000  00000000  00002004  2**0
                  CONTENTS, READONLY
  7 .comment      00000045  00000000  00000000  0000202e  2**0
                  CONTENTS, READONLY
  8 .debug_info   000033d6  00000000  00000000  00002073  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_abbrev 0000074d  00000000  00000000  00005449  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_loclists 00000393  00000000  00000000  00005b96  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_aranges 00000130  00000000  00000000  00005f29  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_rnglists 000000ec  00000000  00000000  00006059  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_line   00000d2b  00000000  00000000  00006145  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_str    000010f1  00000000  00000000  00006e70  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_frame  00000430  00000000  00000000  00007f64  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00000000 <exception_table>:
		len--;
	}
}

void dbg_write_u16(const unsigned short *val, long len)
{
   0:	c0 01 01 20 f1 02 00 00 ed 02 00 00 ed 02 00 00     ... ............
	unsigned long dcc_data;

	dbg_write(TARGET_REQ_DEBUGMSG_HEXMSG(2) | ((len & 0xffff) << 16));
  10:	ed 02 00 00 ed 02 00 00 ed 02 00 00 00 00 00 00     ................
	...

	while (len > 0)
	{
		dcc_data = val[0] | ((len > 1) ? val[1] << 16 : 0x0000);
  2c:	ed 02 00 00 ed 02 00 00 00 00 00 00 ed 02 00 00     ................
	while (len > 0)
  3c:	61 07 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     a...............
  dbg_write_char(':');
  dbg_write_str(caller);
  dbg_write_char('(');
  // this could be more robust; just printing the hex value is easier but less useful
  dbg_write_char(lineNum / 1000 + '0');
  dbg_write_char((lineNum / 100) % 10 + '0');
  4c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  dbg_write_char((lineNum / 10) % 10 + '0');
  5c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  6c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  dbg_write_char(lineNum % 10 + '0');
  dbg_write_char(')');
  7c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................

  // for debugging purposes *this* is all the code we really need
  // don't breakpoint if we're not running via a debugger, otherwise we stop 'forever'
  if ((CoreDebug->DHCSR & CoreDebug_DHCSR_C_DEBUGEN_Msk) == CoreDebug_DHCSR_C_DEBUGEN_Msk)
    __BKPT(0);
  8c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  9c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  ac:	71 07 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     q...............
  bc:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  cc:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
  dc:	ed 02 00 00 ed 02 00 00 ed 02 00 00 00 00 00 00     ................
	...
  f4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 104:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 114:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 124:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 134:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 144:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 154:	ed 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
 178:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 188:	ed 02 00 00 ed 02 00 00 00 00 00 00 ed 02 00 00     ................
 198:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 1a8:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 1b8:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 1c8:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 1d8:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 1e8:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 1f8:	ed 02 00 00 ed 02 00 00 ed 02 00 00 00 00 00 00     ................
 208:	00 00 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 218:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 228:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 238:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 248:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
 258:	ed 02 00 00 ed 02 00 00                             ........

00000260 <deregister_tm_clones>:
 260:	4803      	ldr	r0, [pc, #12]	@ (270 <deregister_tm_clones+0x10>)
 262:	4b04      	ldr	r3, [pc, #16]	@ (274 <deregister_tm_clones+0x14>)
 264:	4283      	cmp	r3, r0
 266:	d002      	beq.n	26e <deregister_tm_clones+0xe>
 268:	4b03      	ldr	r3, [pc, #12]	@ (278 <deregister_tm_clones+0x18>)
 26a:	b103      	cbz	r3, 26e <deregister_tm_clones+0xe>
 26c:	4718      	bx	r3
 26e:	4770      	bx	lr
 270:	000009e0 	.word	0x000009e0
 274:	000009e0 	.word	0x000009e0
 278:	00000000 	.word	0x00000000

0000027c <register_tm_clones>:
 27c:	4805      	ldr	r0, [pc, #20]	@ (294 <register_tm_clones+0x18>)
 27e:	4b06      	ldr	r3, [pc, #24]	@ (298 <register_tm_clones+0x1c>)
 280:	1a1b      	subs	r3, r3, r0
 282:	0fd9      	lsrs	r1, r3, #31
 284:	eb01 01a3 	add.w	r1, r1, r3, asr #2
 288:	1049      	asrs	r1, r1, #1
 28a:	d002      	beq.n	292 <register_tm_clones+0x16>
 28c:	4b03      	ldr	r3, [pc, #12]	@ (29c <register_tm_clones+0x20>)
 28e:	b103      	cbz	r3, 292 <register_tm_clones+0x16>
 290:	4718      	bx	r3
 292:	4770      	bx	lr
 294:	000009e0 	.word	0x000009e0
 298:	000009e0 	.word	0x000009e0
 29c:	00000000 	.word	0x00000000

000002a0 <__do_global_dtors_aux>:
 2a0:	b510      	push	{r4, lr}
 2a2:	4c06      	ldr	r4, [pc, #24]	@ (2bc <__do_global_dtors_aux+0x1c>)
 2a4:	7823      	ldrb	r3, [r4, #0]
 2a6:	b943      	cbnz	r3, 2ba <__do_global_dtors_aux+0x1a>
 2a8:	f7ff ffda 	bl	260 <deregister_tm_clones>
 2ac:	4b04      	ldr	r3, [pc, #16]	@ (2c0 <__do_global_dtors_aux+0x20>)
 2ae:	b113      	cbz	r3, 2b6 <__do_global_dtors_aux+0x16>
 2b0:	4804      	ldr	r0, [pc, #16]	@ (2c4 <__do_global_dtors_aux+0x24>)
 2b2:	f3af 8000 	nop.w
 2b6:	2301      	movs	r3, #1
 2b8:	7023      	strb	r3, [r4, #0]
 2ba:	bd10      	pop	{r4, pc}
 2bc:	20000004 	.word	0x20000004
 2c0:	00000000 	.word	0x00000000
 2c4:	000009e0 	.word	0x000009e0

000002c8 <frame_dummy>:
 2c8:	b508      	push	{r3, lr}
 2ca:	4b05      	ldr	r3, [pc, #20]	@ (2e0 <frame_dummy+0x18>)
 2cc:	b11b      	cbz	r3, 2d6 <frame_dummy+0xe>
 2ce:	4905      	ldr	r1, [pc, #20]	@ (2e4 <frame_dummy+0x1c>)
 2d0:	4805      	ldr	r0, [pc, #20]	@ (2e8 <frame_dummy+0x20>)
 2d2:	f3af 8000 	nop.w
 2d6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 2da:	f7ff bfcf 	b.w	27c <register_tm_clones>
 2de:	bf00      	nop
 2e0:	00000000 	.word	0x00000000
 2e4:	20000008 	.word	0x20000008
 2e8:	000009e0 	.word	0x000009e0

000002ec <Dummy_Handler>:
 2ec:	e7fe      	b.n	2ec <Dummy_Handler>
	...

000002f0 <Reset_Handler>:
 2f0:	b508      	push	{r3, lr}
 2f2:	4a1a      	ldr	r2, [pc, #104]	@ (35c <Reset_Handler+0x6c>)
 2f4:	4b1a      	ldr	r3, [pc, #104]	@ (360 <Reset_Handler+0x70>)
 2f6:	429a      	cmp	r2, r3
 2f8:	d010      	beq.n	31c <Reset_Handler+0x2c>
 2fa:	461a      	mov	r2, r3
 2fc:	4b19      	ldr	r3, [pc, #100]	@ (364 <Reset_Handler+0x74>)
 2fe:	429a      	cmp	r2, r3
 300:	d20c      	bcs.n	31c <Reset_Handler+0x2c>
 302:	1e58      	subs	r0, r3, #1
 304:	1a80      	subs	r0, r0, r2
 306:	f020 0003 	bic.w	r0, r0, #3
 30a:	3004      	adds	r0, #4
 30c:	4b13      	ldr	r3, [pc, #76]	@ (35c <Reset_Handler+0x6c>)
 30e:	4418      	add	r0, r3
 310:	f853 1b04 	ldr.w	r1, [r3], #4
 314:	f842 1b04 	str.w	r1, [r2], #4
 318:	4283      	cmp	r3, r0
 31a:	d1f9      	bne.n	310 <Reset_Handler+0x20>
 31c:	4a12      	ldr	r2, [pc, #72]	@ (368 <Reset_Handler+0x78>)
 31e:	4b13      	ldr	r3, [pc, #76]	@ (36c <Reset_Handler+0x7c>)
 320:	429a      	cmp	r2, r3
 322:	d20b      	bcs.n	33c <Reset_Handler+0x4c>
 324:	4613      	mov	r3, r2
 326:	4a12      	ldr	r2, [pc, #72]	@ (370 <Reset_Handler+0x80>)
 328:	1ad2      	subs	r2, r2, r3
 32a:	f022 0203 	bic.w	r2, r2, #3
 32e:	3204      	adds	r2, #4
 330:	441a      	add	r2, r3
 332:	2100      	movs	r1, #0
 334:	f843 1b04 	str.w	r1, [r3], #4
 338:	429a      	cmp	r2, r3
 33a:	d1fb      	bne.n	334 <Reset_Handler+0x44>
 33c:	4b0d      	ldr	r3, [pc, #52]	@ (374 <Reset_Handler+0x84>)
 33e:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 342:	4a0d      	ldr	r2, [pc, #52]	@ (378 <Reset_Handler+0x88>)
 344:	6093      	str	r3, [r2, #8]
 346:	4b0d      	ldr	r3, [pc, #52]	@ (37c <Reset_Handler+0x8c>)
 348:	b103      	cbz	r3, 34c <Reset_Handler+0x5c>
 34a:	4798      	blx	r3
 34c:	f000 fa8e 	bl	86c <__libc_init_array>
 350:	4b0b      	ldr	r3, [pc, #44]	@ (380 <Reset_Handler+0x90>)
 352:	b103      	cbz	r3, 356 <Reset_Handler+0x66>
 354:	4798      	blx	r3
 356:	f000 fa19 	bl	78c <main>
 35a:	e7fe      	b.n	35a <Reset_Handler+0x6a>
 35c:	000009e0 	.word	0x000009e0
 360:	20000000 	.word	0x20000000
 364:	20000004 	.word	0x20000004
 368:	20000004 	.word	0x20000004
 36c:	200001c0 	.word	0x200001c0
 370:	200001bf 	.word	0x200001bf
 374:	00000000 	.word	0x00000000
 378:	e000ed00 	.word	0xe000ed00
	...

00000384 <dbg_write>:
	if ((CoreDebug->DHCSR & CoreDebug_DHCSR_C_DEBUGEN_Msk) == CoreDebug_DHCSR_C_DEBUGEN_Msk)
 384:	4b0b      	ldr	r3, [pc, #44]	@ (3b4 <dbg_write+0x30>)
 386:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 38a:	f013 0f01 	tst.w	r3, #1
 38e:	d00f      	beq.n	3b0 <dbg_write+0x2c>
 390:	2104      	movs	r1, #4
			while (NVIC_DBG_DATA_R & BUSY)
 392:	4a08      	ldr	r2, [pc, #32]	@ (3b4 <dbg_write+0x30>)
 394:	f8b2 30f8 	ldrh.w	r3, [r2, #248]	@ 0xf8
 398:	f013 0f01 	tst.w	r3, #1
 39c:	d1fa      	bne.n	394 <dbg_write+0x10>
			NVIC_DBG_DATA_R = (unsigned short)(((dcc_data & 0xff) << 8) | BUSY);
 39e:	0203      	lsls	r3, r0, #8
 3a0:	f043 0301 	orr.w	r3, r3, #1
 3a4:	b29b      	uxth	r3, r3
 3a6:	f8a2 30f8 	strh.w	r3, [r2, #248]	@ 0xf8
			dcc_data >>= 8;
 3aa:	0a00      	lsrs	r0, r0, #8
		while (len--)
 3ac:	3901      	subs	r1, #1
 3ae:	d1f1      	bne.n	394 <dbg_write+0x10>
}
 3b0:	4770      	bx	lr
 3b2:	bf00      	nop
 3b4:	e000ed00 	.word	0xe000ed00

000003b8 <dbg_write_u8>:
		len -= 2;
	}
}

void dbg_write_u8(const unsigned char *val, long len)
{
 3b8:	b570      	push	{r4, r5, r6, lr}
 3ba:	4605      	mov	r5, r0
 3bc:	460c      	mov	r4, r1
	unsigned long dcc_data;

	dbg_write(TARGET_REQ_DEBUGMSG_HEXMSG(1) | ((len & 0xffff) << 16));
 3be:	f240 1001 	movw	r0, #257	@ 0x101
 3c2:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 3c6:	f7ff ffdd 	bl	384 <dbg_write>

	while (len > 0)
 3ca:	2c00      	cmp	r4, #0
 3cc:	dd1f      	ble.n	40e <dbg_write_u8+0x56>
 3ce:	3504      	adds	r5, #4
	{
		dcc_data = val[0] | ((len > 1) ? val[1] << 8 : 0x00) | ((len > 2) ? val[2] << 16 : 0x00) | ((len > 3) ? val[3] << 24 : 0x00);
 3d0:	2600      	movs	r6, #0
 3d2:	4628      	mov	r0, r5
 3d4:	f815 3c04 	ldrb.w	r3, [r5, #-4]
 3d8:	2c01      	cmp	r4, #1
 3da:	bfc6      	itte	gt
 3dc:	f815 2c03 	ldrbgt.w	r2, [r5, #-3]
 3e0:	0212      	lslgt	r2, r2, #8
 3e2:	4632      	movle	r2, r6
 3e4:	4313      	orrs	r3, r2
 3e6:	2c02      	cmp	r4, #2
 3e8:	bfc6      	itte	gt
 3ea:	f815 2c02 	ldrbgt.w	r2, [r5, #-2]
 3ee:	0412      	lslgt	r2, r2, #16
 3f0:	4632      	movle	r2, r6
 3f2:	4313      	orrs	r3, r2
 3f4:	2c03      	cmp	r4, #3
 3f6:	bfc6      	itte	gt
 3f8:	f815 0c01 	ldrbgt.w	r0, [r5, #-1]
 3fc:	0600      	lslgt	r0, r0, #24
 3fe:	4630      	movle	r0, r6

		dbg_write(dcc_data);
 400:	4318      	orrs	r0, r3
 402:	f7ff ffbf 	bl	384 <dbg_write>
	while (len > 0)
 406:	3504      	adds	r5, #4
 408:	3c04      	subs	r4, #4
 40a:	2c00      	cmp	r4, #0
 40c:	dce1      	bgt.n	3d2 <dbg_write_u8+0x1a>

		val += 4;
		len -= 4;
	}
}
 40e:	bd70      	pop	{r4, r5, r6, pc}

00000410 <dbg_write_str>:

void dbg_write_str(const char *msg)
{
 410:	b570      	push	{r4, r5, r6, lr}
	long len;
	unsigned long dcc_data;

	for (len = 0; msg[len] && (len < 65536); len++)
 412:	7803      	ldrb	r3, [r0, #0]
 414:	b3ab      	cbz	r3, 482 <dbg_write_str+0x72>
 416:	4605      	mov	r5, r0
 418:	4603      	mov	r3, r0
 41a:	2400      	movs	r4, #0
 41c:	3401      	adds	r4, #1
 41e:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 422:	b132      	cbz	r2, 432 <dbg_write_str+0x22>
 424:	f5b4 3f80 	cmp.w	r4, #65536	@ 0x10000
 428:	d1f8      	bne.n	41c <dbg_write_str+0xc>
		;

	dbg_write(TARGET_REQ_DEBUGMSG_ASCII | ((len & 0xffff) << 16));
 42a:	2001      	movs	r0, #1
 42c:	f7ff ffaa 	bl	384 <dbg_write>

	while (len > 0)
 430:	e006      	b.n	440 <dbg_write_str+0x30>
	dbg_write(TARGET_REQ_DEBUGMSG_ASCII | ((len & 0xffff) << 16));
 432:	0420      	lsls	r0, r4, #16
 434:	f040 0001 	orr.w	r0, r0, #1
 438:	f7ff ffa4 	bl	384 <dbg_write>
	while (len > 0)
 43c:	2c00      	cmp	r4, #0
 43e:	dd1f      	ble.n	480 <dbg_write_str+0x70>
 440:	3504      	adds	r5, #4
	{
		dcc_data = msg[0] | ((len > 1) ? msg[1] << 8 : 0x00) | ((len > 2) ? msg[2] << 16 : 0x00) | ((len > 3) ? msg[3] << 24 : 0x00);
 442:	2600      	movs	r6, #0
 444:	4628      	mov	r0, r5
 446:	f815 3c04 	ldrb.w	r3, [r5, #-4]
 44a:	2c01      	cmp	r4, #1
 44c:	bfc6      	itte	gt
 44e:	f815 2c03 	ldrbgt.w	r2, [r5, #-3]
 452:	0212      	lslgt	r2, r2, #8
 454:	4632      	movle	r2, r6
 456:	4313      	orrs	r3, r2
 458:	2c02      	cmp	r4, #2
 45a:	bfc6      	itte	gt
 45c:	f815 2c02 	ldrbgt.w	r2, [r5, #-2]
 460:	0412      	lslgt	r2, r2, #16
 462:	4632      	movle	r2, r6
 464:	4313      	orrs	r3, r2
 466:	2c03      	cmp	r4, #3
 468:	bfc6      	itte	gt
 46a:	f815 0c01 	ldrbgt.w	r0, [r5, #-1]
 46e:	0600      	lslgt	r0, r0, #24
 470:	4630      	movle	r0, r6
		dbg_write(dcc_data);
 472:	4318      	orrs	r0, r3
 474:	f7ff ff86 	bl	384 <dbg_write>
	while (len > 0)
 478:	3504      	adds	r5, #4
 47a:	3c04      	subs	r4, #4
 47c:	2c00      	cmp	r4, #0
 47e:	dce1      	bgt.n	444 <dbg_write_str+0x34>

		msg += 4;
		len -= 4;
	}
}
 480:	bd70      	pop	{r4, r5, r6, pc}
	dbg_write(TARGET_REQ_DEBUGMSG_ASCII | ((len & 0xffff) << 16));
 482:	2001      	movs	r0, #1
 484:	f7ff ff7e 	bl	384 <dbg_write>
	while (len > 0)
 488:	e7fa      	b.n	480 <dbg_write_str+0x70>
	...

0000048c <clkButton>:
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 48c:	4b04      	ldr	r3, [pc, #16]	@ (4a0 <clkButton+0x14>)
 48e:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
 492:	601a      	str	r2, [r3, #0]
void clkButton(){

	//enable intterrupt
    NVIC_EnableIRQ(EIC_EXTINT_15_IRQn);

    MCLK_REGS->MCLK_APBAMASK |= MCLK_APBAMASK_EIC_Msk;
 494:	4a03      	ldr	r2, [pc, #12]	@ (4a4 <clkButton+0x18>)
 496:	6953      	ldr	r3, [r2, #20]
 498:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 49c:	6153      	str	r3, [r2, #20]

}//clkButton
 49e:	4770      	bx	lr
 4a0:	e000e100 	.word	0xe000e100
 4a4:	40000800 	.word	0x40000800

000004a8 <initButton>:

void initButton(){


   	EIC_REGS->EIC_CONFIG[1] |= ((uint32_t)(EXTINT15_MASK)<<16) | EIC_CONFIG_SENSE7_RISE;
 4a8:	4b0b      	ldr	r3, [pc, #44]	@ (4d8 <initButton+0x30>)
 4aa:	6a1a      	ldr	r2, [r3, #32]
 4ac:	f042 4210 	orr.w	r2, r2, #2415919104	@ 0x90000000
 4b0:	621a      	str	r2, [r3, #32]
	EIC_REGS->EIC_DEBOUNCEN |= EXTINT15_MASK;
 4b2:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 4b4:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 4b8:	631a      	str	r2, [r3, #48]	@ 0x30
	EIC_REGS->EIC_DPRESCALER |= EIC_DPRESCALER_TICKON_Msk | EIC_DPRESCALER_STATES1_Msk |  EIC_DPRESCALER_PRESCALER1_DIV64;
 4ba:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 4bc:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 4c0:	f042 02d0 	orr.w	r2, r2, #208	@ 0xd0
 4c4:	635a      	str	r2, [r3, #52]	@ 0x34
	EIC_REGS->EIC_INTENSET |= EXTINT15_MASK;
 4c6:	691a      	ldr	r2, [r3, #16]
 4c8:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 4cc:	611a      	str	r2, [r3, #16]
	EIC_REGS->EIC_CTRLA |= EIC_CTRLA_CKSEL_CLK_ULP32K | EIC_CTRLA_ENABLE_Msk; 
 4ce:	781a      	ldrb	r2, [r3, #0]
 4d0:	f042 0212 	orr.w	r2, r2, #18
 4d4:	701a      	strb	r2, [r3, #0]

}//initButton
 4d6:	4770      	bx	lr
 4d8:	40002800 	.word	0x40002800

000004dc <port15Init>:

void port15Init(){

 	// switch input on PA15, processed as an external interrupt
  	PORT_REGS->GROUP[0].PORT_DIRCLR = PORT_PA15;
 4dc:	4b0b      	ldr	r3, [pc, #44]	@ (50c <port15Init+0x30>)
 4de:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 4e2:	6059      	str	r1, [r3, #4]
  	PORT_REGS->GROUP[0].PORT_PINCFG[15] |= PORT_PINCFG_PMUXEN_Msk;
 4e4:	f893 204f 	ldrb.w	r2, [r3, #79]	@ 0x4f
 4e8:	f042 0201 	orr.w	r2, r2, #1
 4ec:	f883 204f 	strb.w	r2, [r3, #79]	@ 0x4f
  	PORT_REGS->GROUP[0].PORT_PMUX[7] |= PORT_PMUX_PMUXO_A;
 4f0:	f893 2037 	ldrb.w	r2, [r3, #55]	@ 0x37
 4f4:	b2d2      	uxtb	r2, r2
 4f6:	f883 2037 	strb.w	r2, [r3, #55]	@ 0x37
	PORT_REGS->GROUP[0].PORT_OUTSET = PORT_PA15;
 4fa:	6199      	str	r1, [r3, #24]
	PORT_REGS->GROUP[0].PORT_PINCFG[15] |= PORT_PINCFG_PULLEN_Msk;
 4fc:	f893 204f 	ldrb.w	r2, [r3, #79]	@ 0x4f
 500:	f042 0204 	orr.w	r2, r2, #4
 504:	f883 204f 	strb.w	r2, [r3, #79]	@ 0x4f

 508:	4770      	bx	lr
 50a:	bf00      	nop
 50c:	41008000 	.word	0x41008000

00000510 <clkUART>:


void clkUART(){
    //DFLL0 not DPLL
    //I want the UART on an 8mhz clock for maybe uneducated reasons (I want it to get 1mbps transmit speed)
    GCLK_REGS->GCLK_GENCTRL[4] = GCLK_GENCTRL_DIV(3) | GCLK_GENCTRL_SRC_DFLL | GCLK_GENCTRL_GENEN_Msk;
 510:	4b0f      	ldr	r3, [pc, #60]	@ (550 <clkUART+0x40>)
 512:	4a10      	ldr	r2, [pc, #64]	@ (554 <clkUART+0x44>)
 514:	631a      	str	r2, [r3, #48]	@ 0x30
	GCLK_REGS->GCLK_PCHCTRL[SERCOM0_GCLK_ID_CORE] = GCLK_PCHCTRL_GEN_GCLK4 | GCLK_PCHCTRL_CHEN_Msk;
 516:	2244      	movs	r2, #68	@ 0x44
 518:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c

	while((GCLK_REGS->GCLK_PCHCTRL[SERCOM0_GCLK_ID_CORE] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk){
 51c:	461a      	mov	r2, r3
 51e:	f8d2 309c 	ldr.w	r3, [r2, #156]	@ 0x9c
 522:	f013 0f40 	tst.w	r3, #64	@ 0x40
 526:	d0fa      	beq.n	51e <clkUART+0xe>
		//wait for sync
	}//while	

    GCLK_REGS->GCLK_PCHCTRL[SERCOM4_GCLK_ID_CORE] = GCLK_PCHCTRL_GEN_GCLK4 | GCLK_PCHCTRL_CHEN_Msk;
 528:	4b09      	ldr	r3, [pc, #36]	@ (550 <clkUART+0x40>)
 52a:	2244      	movs	r2, #68	@ 0x44
 52c:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
    while((GCLK_REGS->GCLK_PCHCTRL[SERCOM4_GCLK_ID_CORE] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk){
 530:	461a      	mov	r2, r3
 532:	f8d2 3108 	ldr.w	r3, [r2, #264]	@ 0x108
 536:	f013 0f40 	tst.w	r3, #64	@ 0x40
 53a:	d0fa      	beq.n	532 <clkUART+0x22>
		//wait for sync
	}//while	

    MCLK_REGS->MCLK_APBAMASK |= MCLK_APBAMASK_SERCOM0_Msk;
 53c:	4b06      	ldr	r3, [pc, #24]	@ (558 <clkUART+0x48>)
 53e:	695a      	ldr	r2, [r3, #20]
 540:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
 544:	615a      	str	r2, [r3, #20]
    MCLK_REGS->MCLK_APBDMASK |= MCLK_APBDMASK_SERCOM4_Msk;
 546:	6a1a      	ldr	r2, [r3, #32]
 548:	f042 0201 	orr.w	r2, r2, #1
 54c:	621a      	str	r2, [r3, #32]

}
 54e:	4770      	bx	lr
 550:	40001c00 	.word	0x40001c00
 554:	00030106 	.word	0x00030106
 558:	40000800 	.word	0x40000800

0000055c <initUART>:
void initUART(){

    //The following comes from section 34.6.2.1
    //disable the USART sercom
    SERCOM0_REGS->USART_INT.SERCOM_CTRLA =/*  */ SERCOM_USART_INT_CTRLA_ENABLE(0);
 55c:	4b17      	ldr	r3, [pc, #92]	@ (5bc <initUART+0x60>)
 55e:	2200      	movs	r2, #0
 560:	601a      	str	r2, [r3, #0]
    SERCOM4_REGS->USART_INT.SERCOM_CTRLA = SERCOM_USART_INT_CTRLA_ENABLE(0);  
 562:	f04f 4186 	mov.w	r1, #1124073472	@ 0x43000000
 566:	600a      	str	r2, [r1, #0]
    //The following sets up CTRLA as follows
    //selects async mode, with internal clock, RX (PAD1) and TX (PAD0) on SERCOM0 with internal clock, sets to MSB mode
    //Not sure if we want TXP0 as mode 0x0 (sercom pad 0 for rx but pad 1 gets used for exck) or mode 0x2 where we dont use pad 1 for anything else. 

    //The following sets up CTRLB as follows
    SERCOM0_REGS->USART_INT.SERCOM_CTRLB = SERCOM_USART_INT_CTRLB_CHSIZE_8_BIT | SERCOM_USART_INT_CTRLB_SBMODE_1_BIT | SERCOM_USART_INT_CTRLB_TXEN_Msk | SERCOM_USART_INT_CTRLB_RXEN_Msk;
 568:	f44f 3240 	mov.w	r2, #196608	@ 0x30000
 56c:	605a      	str	r2, [r3, #4]
    while((SERCOM0_REGS->USART_INT.SERCOM_SYNCBUSY & SERCOM_USART_INT_SYNCBUSY_CTRLB_Msk) != 0){
 56e:	461a      	mov	r2, r3
 570:	69d3      	ldr	r3, [r2, #28]
 572:	f013 0f04 	tst.w	r3, #4
 576:	d1fb      	bne.n	570 <initUART+0x14>
        //Wait for CTRLB enable
    }
    SERCOM4_REGS->USART_INT.SERCOM_CTRLB = SERCOM_USART_INT_CTRLB_CHSIZE_8_BIT | SERCOM_USART_INT_CTRLB_SBMODE_1_BIT | SERCOM_USART_INT_CTRLB_TXEN_Msk | SERCOM_USART_INT_CTRLB_RXEN_Msk;
 578:	f04f 4386 	mov.w	r3, #1124073472	@ 0x43000000
 57c:	f44f 3240 	mov.w	r2, #196608	@ 0x30000
 580:	605a      	str	r2, [r3, #4]
    while((SERCOM4_REGS->USART_INT.SERCOM_SYNCBUSY & SERCOM_USART_INT_SYNCBUSY_CTRLB_Msk) != 0){
 582:	461a      	mov	r2, r3
 584:	69d3      	ldr	r3, [r2, #28]
 586:	f013 0f04 	tst.w	r3, #4
 58a:	d1fb      	bne.n	584 <initUART+0x28>
        //Wait for CTRLB enable
    } 

    //Since we are using internal clock we can set desired baud rate with our 8Mhz clock (gclk4)
    SERCOM0_REGS->USART_INT.SERCOM_BAUD = SERCOM_USART_INT_BAUD_BAUD(UART_BUAD);
 58c:	4b0b      	ldr	r3, [pc, #44]	@ (5bc <initUART+0x60>)
 58e:	2200      	movs	r2, #0
 590:	819a      	strh	r2, [r3, #12]
    SERCOM4_REGS->USART_INT.SERCOM_BAUD = SERCOM_USART_INT_BAUD_BAUD(UART_BUAD);
 592:	f04f 4186 	mov.w	r1, #1124073472	@ 0x43000000
 596:	818a      	strh	r2, [r1, #12]

    //enable transmit and receive
    

    //Enable sercom
    SERCOM0_REGS->USART_INT.SERCOM_CTRLA = SERCOM_USART_INT_CTRLA_MODE_USART_INT_CLK |  SERCOM_USART_INT_CTRLA_RXPO(SERCOM0_RX_MODE) | SERCOM_USART_INT_CTRLA_TXPO(SERCOM0_TX_MODE) | SERCOM_USART_INT_CTRLA_DORD_Msk | SERCOM_USART_INT_CTRLA_ENABLE_Msk;
 598:	4a09      	ldr	r2, [pc, #36]	@ (5c0 <initUART+0x64>)
 59a:	601a      	str	r2, [r3, #0]
    while((SERCOM0_REGS->USART_INT.SERCOM_SYNCBUSY & SERCOM_USART_INT_SYNCBUSY_ENABLE_Msk) != 0){
 59c:	461a      	mov	r2, r3
 59e:	69d3      	ldr	r3, [r2, #28]
 5a0:	f013 0f02 	tst.w	r3, #2
 5a4:	d1fb      	bne.n	59e <initUART+0x42>
        //Wait for enable
    }
    SERCOM4_REGS->USART_INT.SERCOM_CTRLA = SERCOM_USART_INT_CTRLA_MODE_USART_INT_CLK |  SERCOM_USART_INT_CTRLA_RXPO(SERCOM4_RX_MODE) | SERCOM_USART_INT_CTRLA_TXPO(SERCOM4_TX_MODE) | SERCOM_USART_INT_CTRLA_DORD_Msk | SERCOM_USART_INT_CTRLA_ENABLE_Msk;
 5a6:	f04f 4386 	mov.w	r3, #1124073472	@ 0x43000000
 5aa:	4a05      	ldr	r2, [pc, #20]	@ (5c0 <initUART+0x64>)
 5ac:	601a      	str	r2, [r3, #0]
    while((SERCOM4_REGS->USART_INT.SERCOM_SYNCBUSY & SERCOM_USART_INT_SYNCBUSY_ENABLE_Msk) != 0){
 5ae:	461a      	mov	r2, r3
 5b0:	69d3      	ldr	r3, [r2, #28]
 5b2:	f013 0f02 	tst.w	r3, #2
 5b6:	d1fb      	bne.n	5b0 <initUART+0x54>
        //Wait for enable
    } 
}
 5b8:	4770      	bx	lr
 5ba:	bf00      	nop
 5bc:	40003000 	.word	0x40003000
 5c0:	40100006 	.word	0x40100006

000005c4 <portUART>:
void portUART(){
    
    //USART sercom0 on PORT_PA8
    PORT_REGS->GROUP[0].PORT_PINCFG[8] |= PORT_PINCFG_PMUXEN_Msk;
 5c4:	4b21      	ldr	r3, [pc, #132]	@ (64c <portUART+0x88>)
 5c6:	f893 2048 	ldrb.w	r2, [r3, #72]	@ 0x48
 5ca:	f042 0201 	orr.w	r2, r2, #1
 5ce:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
    PORT_REGS->GROUP[0].PORT_PMUX[4] |= PORT_PMUX_PMUXE_C;
 5d2:	f893 2034 	ldrb.w	r2, [r3, #52]	@ 0x34
 5d6:	f042 0202 	orr.w	r2, r2, #2
 5da:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

 //USART sercom0 on PORT_PA9
    PORT_REGS->GROUP[0].PORT_PINCFG[9] |= PORT_PINCFG_PMUXEN_Msk;
 5de:	f893 2049 	ldrb.w	r2, [r3, #73]	@ 0x49
 5e2:	f042 0201 	orr.w	r2, r2, #1
 5e6:	f883 2049 	strb.w	r2, [r3, #73]	@ 0x49
    PORT_REGS->GROUP[0].PORT_PMUX[4] |= PORT_PMUX_PMUXO_C;
 5ea:	f893 2034 	ldrb.w	r2, [r3, #52]	@ 0x34
 5ee:	f042 0220 	orr.w	r2, r2, #32
 5f2:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

//USART SERCOM4 on PORT_PA12
    PORT_REGS->GROUP[1].PORT_PINCFG[12] |= PORT_PINCFG_PMUXEN_Msk;
 5f6:	f893 20cc 	ldrb.w	r2, [r3, #204]	@ 0xcc
 5fa:	f042 0201 	orr.w	r2, r2, #1
 5fe:	f883 20cc 	strb.w	r2, [r3, #204]	@ 0xcc
    PORT_REGS->GROUP[1].PORT_PMUX[6] |= PORT_PMUX_PMUXE_C;
 602:	f893 20b6 	ldrb.w	r2, [r3, #182]	@ 0xb6
 606:	f042 0202 	orr.w	r2, r2, #2
 60a:	f883 20b6 	strb.w	r2, [r3, #182]	@ 0xb6

 //USART SERCOM4 on PORT_PA13
    PORT_REGS->GROUP[1].PORT_PINCFG[13] |= PORT_PINCFG_PMUXEN_Msk;
 60e:	f893 20cd 	ldrb.w	r2, [r3, #205]	@ 0xcd
 612:	f042 0201 	orr.w	r2, r2, #1
 616:	f883 20cd 	strb.w	r2, [r3, #205]	@ 0xcd
    PORT_REGS->GROUP[1].PORT_PMUX[6] |= PORT_PMUX_PMUXO_C; 
 61a:	f893 20b6 	ldrb.w	r2, [r3, #182]	@ 0xb6
 61e:	f042 0220 	orr.w	r2, r2, #32
 622:	f883 20b6 	strb.w	r2, [r3, #182]	@ 0xb6

    //PA04 for one DE FOR PAD 1 SERCOM4
    PORT_REGS->GROUP[0].PORT_DIRSET = PORT_PA04;
 626:	2210      	movs	r2, #16
 628:	609a      	str	r2, [r3, #8]
    PORT_REGS->GROUP[0].PORT_OUTSET = PORT_PA04;
 62a:	619a      	str	r2, [r3, #24]

    //P18 for RE FOR PAD 1
    PORT_REGS->GROUP[0].PORT_DIRSET = PORT_PA18;
 62c:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
 630:	609a      	str	r2, [r3, #8]
    PORT_REGS->GROUP[0].PORT_OUTSET = PORT_PA18;
 632:	619a      	str	r2, [r3, #24]

    //PB05 for one DE for pad 2 SERCOM0
    PORT_REGS->GROUP[1].PORT_DIRSET = PORT_PB05;
 634:	2220      	movs	r2, #32
 636:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
    PORT_REGS->GROUP[1].PORT_OUTSET = PORT_PB05;
 63a:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98

    //PB14 for RE for pad 2
    PORT_REGS->GROUP[1].PORT_DIRSET = PORT_PB14;
 63e:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 642:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
    PORT_REGS->GROUP[1].PORT_OUTSET = PORT_PB14;
 646:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98



}
 64a:	4770      	bx	lr
 64c:	41008000 	.word	0x41008000

00000650 <rxMode>:

void rxMode(sercom_registers_t* sercom){

    if(sercom == SERCOM0_REGS){
 650:	4b08      	ldr	r3, [pc, #32]	@ (674 <rxMode+0x24>)
 652:	4298      	cmp	r0, r3
 654:	d003      	beq.n	65e <rxMode+0xe>

    //PB14 and PB05for RE and DE for pad 2
        PORT_REGS->GROUP[1].PORT_OUTCLR = PORT_PB14 | PORT_PB05;

    } 
    else if(sercom == SERCOM4_REGS){
 656:	f1b0 4f86 	cmp.w	r0, #1124073472	@ 0x43000000
 65a:	d006      	beq.n	66a <rxMode+0x1a>



    }

}
 65c:	4770      	bx	lr
        PORT_REGS->GROUP[1].PORT_OUTCLR = PORT_PB14 | PORT_PB05;
 65e:	4b06      	ldr	r3, [pc, #24]	@ (678 <rxMode+0x28>)
 660:	f244 0220 	movw	r2, #16416	@ 0x4020
 664:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
 668:	4770      	bx	lr
        PORT_REGS->GROUP[0].PORT_OUTCLR = PORT_PA04 | PORT_PA18;
 66a:	4b03      	ldr	r3, [pc, #12]	@ (678 <rxMode+0x28>)
 66c:	4a03      	ldr	r2, [pc, #12]	@ (67c <rxMode+0x2c>)
 66e:	615a      	str	r2, [r3, #20]
}
 670:	e7f4      	b.n	65c <rxMode+0xc>
 672:	bf00      	nop
 674:	40003000 	.word	0x40003000
 678:	41008000 	.word	0x41008000
 67c:	00040010 	.word	0x00040010

00000680 <txMode>:

void txMode(sercom_registers_t* sercom){

    if(sercom == SERCOM0_REGS){
 680:	4b08      	ldr	r3, [pc, #32]	@ (6a4 <txMode+0x24>)
 682:	4298      	cmp	r0, r3
 684:	d003      	beq.n	68e <txMode+0xe>

    //PB14 and PB05 for RE and DE for pad 2
        PORT_REGS->GROUP[1].PORT_OUTSET = PORT_PB14 | PORT_PB05;

    } 
    else if(sercom == SERCOM4_REGS){
 686:	f1b0 4f86 	cmp.w	r0, #1124073472	@ 0x43000000
 68a:	d006      	beq.n	69a <txMode+0x1a>
    //PA04 for one DE FOR PAD 1 SERCOM4
        PORT_REGS->GROUP[0].PORT_OUTSET = PORT_PA04 | PORT_PA18;

    }

}
 68c:	4770      	bx	lr
        PORT_REGS->GROUP[1].PORT_OUTSET = PORT_PB14 | PORT_PB05;
 68e:	4b06      	ldr	r3, [pc, #24]	@ (6a8 <txMode+0x28>)
 690:	f244 0220 	movw	r2, #16416	@ 0x4020
 694:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
 698:	4770      	bx	lr
        PORT_REGS->GROUP[0].PORT_OUTSET = PORT_PA04 | PORT_PA18;
 69a:	4b03      	ldr	r3, [pc, #12]	@ (6a8 <txMode+0x28>)
 69c:	4a03      	ldr	r2, [pc, #12]	@ (6ac <txMode+0x2c>)
 69e:	619a      	str	r2, [r3, #24]
}
 6a0:	e7f4      	b.n	68c <txMode+0xc>
 6a2:	bf00      	nop
 6a4:	40003000 	.word	0x40003000
 6a8:	41008000 	.word	0x41008000
 6ac:	00040010 	.word	0x00040010

000006b0 <txUART>:

void txUART(sercom_registers_t* sercom, uint8_t data){
 6b0:	b538      	push	{r3, r4, r5, lr}
 6b2:	4604      	mov	r4, r0
 6b4:	460d      	mov	r5, r1
    
    txMode(sercom);
 6b6:	f7ff ffe3 	bl	680 <txMode>

    while((sercom->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_DRE_Msk) == 0U ){
 6ba:	7e23      	ldrb	r3, [r4, #24]
 6bc:	f013 0f01 	tst.w	r3, #1
 6c0:	d0fb      	beq.n	6ba <txUART+0xa>
        //WAIT for clear int flag

    }

    sercom->USART_INT.SERCOM_DATA = (uint16_t)data;
 6c2:	62a5      	str	r5, [r4, #40]	@ 0x28


}
 6c4:	bd38      	pop	{r3, r4, r5, pc}

000006c6 <rxUART>:

uint8_t rxUART(sercom_registers_t* sercom){
 6c6:	b510      	push	{r4, lr}
 6c8:	4604      	mov	r4, r0
    
    rxMode(sercom);
 6ca:	f7ff ffc1 	bl	650 <rxMode>

    return sercom->USART_INT.SERCOM_DATA;
 6ce:	6aa0      	ldr	r0, [r4, #40]	@ 0x28

 6d0:	b2c0      	uxtb	r0, r0
 6d2:	bd10      	pop	{r4, pc}

000006d4 <initAllPorts>:
void initAllPorts(){
 6d4:	b508      	push	{r3, lr}
  PORT_REGS->GROUP[0].PORT_DIRSET = PORT_PA14;
 6d6:	4b05      	ldr	r3, [pc, #20]	@ (6ec <initAllPorts+0x18>)
 6d8:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 6dc:	609a      	str	r2, [r3, #8]
  PORT_REGS->GROUP[0].PORT_OUTSET = PORT_PA14;
 6de:	619a      	str	r2, [r3, #24]
  port15Init(); //init button ports
 6e0:	f7ff fefc 	bl	4dc <port15Init>
  portUART(); //init UART ports
 6e4:	f7ff ff6e 	bl	5c4 <portUART>
}//initAllPorts
 6e8:	bd08      	pop	{r3, pc}
 6ea:	bf00      	nop
 6ec:	41008000 	.word	0x41008000

000006f0 <initAllClks>:
void initAllClks(){
 6f0:	b508      	push	{r3, lr}
  clkButton();
 6f2:	f7ff fecb 	bl	48c <clkButton>
  clkUART();
 6f6:	f7ff ff0b 	bl	510 <clkUART>
}//initAllClks
 6fa:	bd08      	pop	{r3, pc}

000006fc <heartInit>:
  // while ((OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLSTATUS & (OSCCTRL_DPLLSTATUS_LOCK_Msk | OSCCTRL_DPLLSTATUS_CLKRDY_Msk)) !=
  //        (OSCCTRL_DPLLSTATUS_LOCK_Msk | OSCCTRL_DPLLSTATUS_CLKRDY_Msk))
  //   ; /* Wait for ready state */

  // define our main generic clock, which drives everything, to be 120MHz from the PLL
  MCLK_REGS->MCLK_CPUDIV = MCLK_CPUDIV_DIV_DIV1;
 6fc:	4b0e      	ldr	r3, [pc, #56]	@ (738 <heartInit+0x3c>)
 6fe:	2201      	movs	r2, #1
 700:	715a      	strb	r2, [r3, #5]
  while ((MCLK_REGS->MCLK_INTFLAG & MCLK_INTFLAG_CKRDY_Msk) != MCLK_INTFLAG_CKRDY_Msk)
 702:	461a      	mov	r2, r3
 704:	78d3      	ldrb	r3, [r2, #3]
 706:	f013 0f01 	tst.w	r3, #1
 70a:	d0fb      	beq.n	704 <heartInit+0x8>
    ; /* Wait for main clock to be ready */

  GCLK_REGS->GCLK_GENCTRL[0] = GCLK_GENCTRL_DIV(24) | GCLK_GENCTRL_SRC_DFLL | GCLK_GENCTRL_GENEN_Msk;
 70c:	4b0b      	ldr	r3, [pc, #44]	@ (73c <heartInit+0x40>)
 70e:	4a0c      	ldr	r2, [pc, #48]	@ (740 <heartInit+0x44>)
 710:	621a      	str	r2, [r3, #32]
  while ((GCLK_REGS->GCLK_SYNCBUSY & GCLK_SYNCBUSY_GENCTRL_GCLK0) == GCLK_SYNCBUSY_GENCTRL_GCLK0)
 712:	461a      	mov	r2, r3
 714:	6853      	ldr	r3, [r2, #4]
 716:	f013 0f04 	tst.w	r3, #4
 71a:	d1fb      	bne.n	714 <heartInit+0x18>
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 71c:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 720:	f240 72cf 	movw	r2, #1999	@ 0x7cf
 724:	615a      	str	r2, [r3, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 726:	4a07      	ldr	r2, [pc, #28]	@ (744 <heartInit+0x48>)
 728:	21e0      	movs	r1, #224	@ 0xe0
 72a:	f882 1023 	strb.w	r1, [r2, #35]	@ 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 72e:	2200      	movs	r2, #0
 730:	619a      	str	r2, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 732:	2207      	movs	r2, #7
 734:	611a      	str	r2, [r3, #16]

  // have to enable the interrupt line in the system level REG
  NVIC_EnableIRQ(SysTick_IRQn);

  SysTick_Config(MS_TICKS);
}
 736:	4770      	bx	lr
 738:	40000800 	.word	0x40000800
 73c:	40001c00 	.word	0x40001c00
 740:	00180106 	.word	0x00180106
 744:	e000ed00 	.word	0xe000ed00

00000748 <initAll>:
void initAll(){
 748:	b508      	push	{r3, lr}
  heartInit();
 74a:	f7ff ffd7 	bl	6fc <heartInit>
  initAllClks();
 74e:	f7ff ffcf 	bl	6f0 <initAllClks>
  initAllPorts();
 752:	f7ff ffbf 	bl	6d4 <initAllPorts>
  initButton();
 756:	f7ff fea7 	bl	4a8 <initButton>
  initUART();
 75a:	f7ff feff 	bl	55c <initUART>
}
 75e:	bd08      	pop	{r3, pc}

00000760 <SysTick_Handler>:


// Fires every 1ms
void SysTick_Handler(){
  msCount++;
 760:	4a02      	ldr	r2, [pc, #8]	@ (76c <SysTick_Handler+0xc>)
 762:	6813      	ldr	r3, [r2, #0]
 764:	3301      	adds	r3, #1
 766:	6013      	str	r3, [r2, #0]
}
 768:	4770      	bx	lr
 76a:	bf00      	nop
 76c:	20000020 	.word	0x20000020

00000770 <EIC_EXTINT_15_Handler>:

// ISR for  external interrupt 15, add processing code as required...
void EIC_EXTINT_15_Handler(){
  PORT_REGS->GROUP[0].PORT_OUTTGL = PORT_PA14;
 770:	4b04      	ldr	r3, [pc, #16]	@ (784 <EIC_EXTINT_15_Handler+0x14>)
 772:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 776:	61da      	str	r2, [r3, #28]
  // clear the interrupt! and go to the next operating mode
  EIC_REGS->EIC_INTFLAG |= EXTINT15_MASK;
 778:	4a03      	ldr	r2, [pc, #12]	@ (788 <EIC_EXTINT_15_Handler+0x18>)
 77a:	6953      	ldr	r3, [r2, #20]
 77c:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 780:	6153      	str	r3, [r2, #20]
}
 782:	4770      	bx	lr
 784:	41008000 	.word	0x41008000
 788:	40002800 	.word	0x40002800

0000078c <main>:
  dbg_write_str("beforee");
  PORT_REGS->GROUP[0].PORT_OUTTGL = PORT_PA14;
  dbg_write_str("afterr");
}

int main(void){
 78c:	b570      	push	{r4, r5, r6, lr}
 78e:	b082      	sub	sp, #8
 790:	4b29      	ldr	r3, [pc, #164]	@ (838 <main+0xac>)



#ifndef NDEBUG
  for (int i = 0; i < DEBUG_WAIT; i++);
 792:	3b01      	subs	r3, #1
 794:	d1fd      	bne.n	792 <main+0x6>

  // enable cache
  // tradeoff: +: really helps with repeated code/data (like when doing animations in a game)
  //           -: results in non-deterministic run-times
  //           +: there *is* a way to lock lines of cache to keep hard deadline code/data pinned in the cache
  if ((CMCC_REGS->CMCC_SR & CMCC_SR_CSTS_Msk) == 0)
 796:	4b29      	ldr	r3, [pc, #164]	@ (83c <main+0xb0>)
 798:	68db      	ldr	r3, [r3, #12]
 79a:	f013 0f01 	tst.w	r3, #1
 79e:	d102      	bne.n	7a6 <main+0x1a>
    CMCC_REGS->CMCC_CTRL = CMCC_CTRL_CEN_Msk;
 7a0:	4b26      	ldr	r3, [pc, #152]	@ (83c <main+0xb0>)
 7a2:	2201      	movs	r2, #1
 7a4:	609a      	str	r2, [r3, #8]

  // sleep to idle (wake on interrupts)
  PM_REGS->PM_SLEEPCFG |= PM_SLEEPCFG_SLEEPMODE_IDLE;
 7a6:	4a26      	ldr	r2, [pc, #152]	@ (840 <main+0xb4>)
 7a8:	7853      	ldrb	r3, [r2, #1]
 7aa:	f043 0302 	orr.w	r3, r3, #2
 7ae:	7053      	strb	r3, [r2, #1]

  initAll();
 7b0:	f7ff ffca 	bl	748 <initAll>
  \details Enables IRQ interrupts by clearing special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 7b4:	b662      	cpsie	i
  // we want interrupts!
  __enable_irq();

  // some example logging calls
#ifndef NDEBUG
  dbg_write_str("~~~DEBUG ENABLED~~~\n");
 7b6:	4823      	ldr	r0, [pc, #140]	@ (844 <main+0xb8>)
 7b8:	f7ff fe2a 	bl	410 <dbg_write_str>
#endif

  PORT_REGS->GROUP[0].PORT_OUTTGL = PORT_PA14;
 7bc:	4b22      	ldr	r3, [pc, #136]	@ (848 <main+0xbc>)
 7be:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 7c2:	61da      	str	r2, [r3, #28]
  // sleep until we have an interrupt
  while (1){
    __WFI();

    if ((msCount % LED_FLASH_MS) == 0){
 7c4:	4c21      	ldr	r4, [pc, #132]	@ (84c <main+0xc0>)
 7c6:	4d22      	ldr	r5, [pc, #136]	@ (850 <main+0xc4>)
      txUART(SERCOM0_REGS ,secCount);
 7c8:	4e22      	ldr	r6, [pc, #136]	@ (854 <main+0xc8>)
 7ca:	e018      	b.n	7fe <main+0x72>
      uint32_t timestamp = 1;
      while((timestamp % TX_DELAY_MS) != 0 ){
        timestamp ++;
      }
      rxMode(SERCOM0_REGS);
 7cc:	4630      	mov	r0, r6
 7ce:	f7ff ff3f 	bl	650 <rxMode>
      secCount = secCount + 1;
 7d2:	6863      	ldr	r3, [r4, #4]
 7d4:	3301      	adds	r3, #1
 7d6:	6063      	str	r3, [r4, #4]
      PORT_REGS->GROUP[0].PORT_OUTTGL = PORT_PA14;
 7d8:	4b1b      	ldr	r3, [pc, #108]	@ (848 <main+0xbc>)
 7da:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 7de:	61da      	str	r2, [r3, #28]
/*       #ifndef NDEBUG
        dbg_write_u32(&secCount,1);
      #endif
 */         
      #ifndef NDEBUG
        rxMode(SERCOM4_REGS);
 7e0:	f04f 4086 	mov.w	r0, #1124073472	@ 0x43000000
 7e4:	f7ff ff34 	bl	650 <rxMode>
        unsigned char rxCount = rxUART(SERCOM4_REGS);
 7e8:	f04f 4086 	mov.w	r0, #1124073472	@ 0x43000000
 7ec:	f7ff ff6b 	bl	6c6 <rxUART>
 7f0:	f88d 0007 	strb.w	r0, [sp, #7]
        dbg_write_u8(&rxCount,1);
 7f4:	2101      	movs	r1, #1
 7f6:	f10d 0007 	add.w	r0, sp, #7
 7fa:	f7ff fddd 	bl	3b8 <dbg_write_u8>
    if ((msCount % LED_FLASH_MS) == 0){
 7fe:	f44f 717a 	mov.w	r1, #1000	@ 0x3e8
    __WFI();
 802:	bf30      	wfi
    if ((msCount % LED_FLASH_MS) == 0){
 804:	6823      	ldr	r3, [r4, #0]
 806:	fba5 0203 	umull	r0, r2, r5, r3
 80a:	0992      	lsrs	r2, r2, #6
 80c:	fb01 3312 	mls	r3, r1, r2, r3
 810:	2b00      	cmp	r3, #0
 812:	d1f6      	bne.n	802 <main+0x76>
      txUART(SERCOM0_REGS ,secCount);
 814:	6861      	ldr	r1, [r4, #4]
 816:	b2c9      	uxtb	r1, r1
 818:	4630      	mov	r0, r6
 81a:	f7ff ff49 	bl	6b0 <txUART>
      uint32_t timestamp = 1;
 81e:	2201      	movs	r2, #1
      while((timestamp % TX_DELAY_MS) != 0 ){
 820:	f44f 61fa 	mov.w	r1, #2000	@ 0x7d0
        timestamp ++;
 824:	3201      	adds	r2, #1
      while((timestamp % TX_DELAY_MS) != 0 ){
 826:	fba5 0302 	umull	r0, r3, r5, r2
 82a:	09db      	lsrs	r3, r3, #7
 82c:	fb01 2313 	mls	r3, r1, r3, r2
 830:	2b00      	cmp	r3, #0
 832:	d1f7      	bne.n	824 <main+0x98>
 834:	e7ca      	b.n	7cc <main+0x40>
 836:	bf00      	nop
 838:	00989680 	.word	0x00989680
 83c:	41006000 	.word	0x41006000
 840:	40000400 	.word	0x40000400
 844:	000009a4 	.word	0x000009a4
 848:	41008000 	.word	0x41008000
 84c:	20000020 	.word	0x20000020
 850:	10624dd3 	.word	0x10624dd3
 854:	40003000 	.word	0x40003000

00000858 <register_fini>:
 858:	4b02      	ldr	r3, [pc, #8]	@ (864 <register_fini+0xc>)
 85a:	b113      	cbz	r3, 862 <register_fini+0xa>
 85c:	4802      	ldr	r0, [pc, #8]	@ (868 <register_fini+0x10>)
 85e:	f000 b845 	b.w	8ec <atexit>
 862:	4770      	bx	lr
 864:	00000000 	.word	0x00000000
 868:	000008bd 	.word	0x000008bd

0000086c <__libc_init_array>:
 86c:	b570      	push	{r4, r5, r6, lr}
 86e:	4b0f      	ldr	r3, [pc, #60]	@ (8ac <__libc_init_array+0x40>)
 870:	4d0f      	ldr	r5, [pc, #60]	@ (8b0 <__libc_init_array+0x44>)
 872:	42ab      	cmp	r3, r5
 874:	eba3 0605 	sub.w	r6, r3, r5
 878:	d007      	beq.n	88a <__libc_init_array+0x1e>
 87a:	10b6      	asrs	r6, r6, #2
 87c:	2400      	movs	r4, #0
 87e:	f855 3b04 	ldr.w	r3, [r5], #4
 882:	3401      	adds	r4, #1
 884:	4798      	blx	r3
 886:	42a6      	cmp	r6, r4
 888:	d8f9      	bhi.n	87e <__libc_init_array+0x12>
 88a:	f000 f897 	bl	9bc <_init>
 88e:	4d09      	ldr	r5, [pc, #36]	@ (8b4 <__libc_init_array+0x48>)
 890:	4b09      	ldr	r3, [pc, #36]	@ (8b8 <__libc_init_array+0x4c>)
 892:	1b5e      	subs	r6, r3, r5
 894:	42ab      	cmp	r3, r5
 896:	ea4f 06a6 	mov.w	r6, r6, asr #2
 89a:	d006      	beq.n	8aa <__libc_init_array+0x3e>
 89c:	2400      	movs	r4, #0
 89e:	f855 3b04 	ldr.w	r3, [r5], #4
 8a2:	3401      	adds	r4, #1
 8a4:	4798      	blx	r3
 8a6:	42a6      	cmp	r6, r4
 8a8:	d8f9      	bhi.n	89e <__libc_init_array+0x32>
 8aa:	bd70      	pop	{r4, r5, r6, pc}
 8ac:	000009c8 	.word	0x000009c8
 8b0:	000009c8 	.word	0x000009c8
 8b4:	000009c8 	.word	0x000009c8
 8b8:	000009d0 	.word	0x000009d0

000008bc <__libc_fini_array>:
 8bc:	b538      	push	{r3, r4, r5, lr}
 8be:	4d07      	ldr	r5, [pc, #28]	@ (8dc <__libc_fini_array+0x20>)
 8c0:	4c07      	ldr	r4, [pc, #28]	@ (8e0 <__libc_fini_array+0x24>)
 8c2:	1b2c      	subs	r4, r5, r4
 8c4:	10a4      	asrs	r4, r4, #2
 8c6:	d005      	beq.n	8d4 <__libc_fini_array+0x18>
 8c8:	3c01      	subs	r4, #1
 8ca:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 8ce:	4798      	blx	r3
 8d0:	2c00      	cmp	r4, #0
 8d2:	d1f9      	bne.n	8c8 <__libc_fini_array+0xc>
 8d4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8d8:	f000 b87a 	b.w	9d0 <_fini>
 8dc:	000009e0 	.word	0x000009e0
 8e0:	000009dc 	.word	0x000009dc

000008e4 <__retarget_lock_acquire_recursive>:
 8e4:	4770      	bx	lr
 8e6:	bf00      	nop

000008e8 <__retarget_lock_release_recursive>:
 8e8:	4770      	bx	lr
 8ea:	bf00      	nop

000008ec <atexit>:
 8ec:	2300      	movs	r3, #0
 8ee:	4601      	mov	r1, r0
 8f0:	461a      	mov	r2, r3
 8f2:	4618      	mov	r0, r3
 8f4:	f000 b800 	b.w	8f8 <__register_exitproc>

000008f8 <__register_exitproc>:
 8f8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8fc:	4d1b      	ldr	r5, [pc, #108]	@ (96c <__register_exitproc+0x74>)
 8fe:	4606      	mov	r6, r0
 900:	6828      	ldr	r0, [r5, #0]
 902:	4698      	mov	r8, r3
 904:	460f      	mov	r7, r1
 906:	4691      	mov	r9, r2
 908:	f7ff ffec 	bl	8e4 <__retarget_lock_acquire_recursive>
 90c:	4b18      	ldr	r3, [pc, #96]	@ (970 <__register_exitproc+0x78>)
 90e:	681c      	ldr	r4, [r3, #0]
 910:	b31c      	cbz	r4, 95a <__register_exitproc+0x62>
 912:	6828      	ldr	r0, [r5, #0]
 914:	6865      	ldr	r5, [r4, #4]
 916:	2d1f      	cmp	r5, #31
 918:	dc22      	bgt.n	960 <__register_exitproc+0x68>
 91a:	b94e      	cbnz	r6, 930 <__register_exitproc+0x38>
 91c:	1c6b      	adds	r3, r5, #1
 91e:	3502      	adds	r5, #2
 920:	6063      	str	r3, [r4, #4]
 922:	f844 7025 	str.w	r7, [r4, r5, lsl #2]
 926:	f7ff ffdf 	bl	8e8 <__retarget_lock_release_recursive>
 92a:	2000      	movs	r0, #0
 92c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 930:	eb04 0185 	add.w	r1, r4, r5, lsl #2
 934:	2301      	movs	r3, #1
 936:	f8c1 9088 	str.w	r9, [r1, #136]	@ 0x88
 93a:	f8d4 2188 	ldr.w	r2, [r4, #392]	@ 0x188
 93e:	40ab      	lsls	r3, r5
 940:	431a      	orrs	r2, r3
 942:	2e02      	cmp	r6, #2
 944:	f8c4 2188 	str.w	r2, [r4, #392]	@ 0x188
 948:	f8c1 8108 	str.w	r8, [r1, #264]	@ 0x108
 94c:	d1e6      	bne.n	91c <__register_exitproc+0x24>
 94e:	f8d4 218c 	ldr.w	r2, [r4, #396]	@ 0x18c
 952:	431a      	orrs	r2, r3
 954:	f8c4 218c 	str.w	r2, [r4, #396]	@ 0x18c
 958:	e7e0      	b.n	91c <__register_exitproc+0x24>
 95a:	4c06      	ldr	r4, [pc, #24]	@ (974 <__register_exitproc+0x7c>)
 95c:	601c      	str	r4, [r3, #0]
 95e:	e7d8      	b.n	912 <__register_exitproc+0x1a>
 960:	f7ff ffc2 	bl	8e8 <__retarget_lock_release_recursive>
 964:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 968:	e7e0      	b.n	92c <__register_exitproc+0x34>
 96a:	bf00      	nop
 96c:	20000000 	.word	0x20000000
 970:	20000028 	.word	0x20000028
 974:	20000030 	.word	0x20000030
 978:	65737341 	.word	0x65737341
 97c:	6f697472 	.word	0x6f697472
 980:	0027206e 	.word	0x0027206e
 984:	61662027 	.word	0x61662027
 988:	64656c69 	.word	0x64656c69
 98c:	206e6920 	.word	0x206e6920
 990:	00000000 	.word	0x00000000
 994:	6f666562 	.word	0x6f666562
 998:	00656572 	.word	0x00656572
 99c:	65746661 	.word	0x65746661
 9a0:	00007272 	.word	0x00007272
 9a4:	447e7e7e 	.word	0x447e7e7e
 9a8:	47554245 	.word	0x47554245
 9ac:	414e4520 	.word	0x414e4520
 9b0:	44454c42 	.word	0x44454c42
 9b4:	0a7e7e7e 	.word	0x0a7e7e7e
 9b8:	00000000 	.word	0x00000000

000009bc <_init>:
 9bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 9be:	bf00      	nop
 9c0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 9c2:	bc08      	pop	{r3}
 9c4:	469e      	mov	lr, r3
 9c6:	4770      	bx	lr

000009c8 <__init_array_start>:
 9c8:	00000859 	.word	0x00000859

000009cc <__frame_dummy_init_array_entry>:
 9cc:	000002c9                                ....

000009d0 <_fini>:
 9d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 9d2:	bf00      	nop
 9d4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 9d6:	bc08      	pop	{r3}
 9d8:	469e      	mov	lr, r3
 9da:	4770      	bx	lr

000009dc <__do_global_dtors_aux_fini_array_entry>:
 9dc:	02a1 0000                                   ....
